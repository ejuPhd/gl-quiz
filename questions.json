{
    "questions": [
        {
            "id": 1,
            "type": "code_completion",
            "category": "linear_regression_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import LinearRegression from scikit-learn:",
            "code_snippet": "from sklearn.______ import LinearRegression",
            "options": [
                "linear_model",
                "models",
                "linear",
                "regression"
            ],
            "correct_answer": 0,
            "explanation": "LinearRegression is located in sklearn.linear_model module"
        },
        {
            "id": 2,
            "type": "code_completion",
            "category": "linear_regression_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a LinearRegression instance:",
            "code_snippet": "model = ______()",
            "options": [
                "LinearRegression",
                "Linear",
                "Regression",
                "LR"
            ],
            "correct_answer": 0,
            "explanation": "LinearRegression() is the correct class constructor"
        },
        {
            "id": 3,
            "type": "error_debugging",
            "category": "data_preparation",
            "difficulty": "intermediate",
            "question": "What's wrong with this feature selection code?",
            "code_snippet": "X = df['annual_income_in_usd']  # Single brackets\nmodel.fit(X, y)",
            "options": [
                "X should use double brackets to remain 2D: df[['annual_income_in_usd']]",
                "y should also use double brackets",
                "The column name is incorrect",
                "Nothing is wrong"
            ],
            "correct_answer": 0,
            "explanation": "scikit-learn requires 2D array for features. Single brackets return Series (1D), double brackets return DataFrame (2D)"
        },
        {
            "id": 4,
            "type": "conceptual",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What does R-squared value represent in linear regression?",
            "options": [
                "The proportion of variance in the target variable explained by the model",
                "The average prediction error",
                "The correlation between features",
                "The model training time"
            ],
            "correct_answer": 0,
            "explanation": "R-squared measures how well the independent variables explain the variability of the dependent variable"
        },
        {
            "id": 5,
            "type": "error_debugging",
            "category": "imports",
            "difficulty": "beginner",
            "question": "Why does this code give 'NameError: name metrics is not defined'?",
            "code_snippet": "from sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nr_squared = metrics.r2_score(y_test, y_pred)",
            "options": [
                "metrics wasn't imported - use 'from sklearn.metrics import r2_score'",
                "metrics should be sklearn.metrics",
                "r2_score function doesn't exist",
                "y_test and y_pred are undefined"
            ],
            "correct_answer": 0,
            "explanation": "The metrics module wasn't imported. Either import the entire module or import r2_score directly"
        },
        {
            "id": 6,
            "type": "code_completion",
            "category": "data_preparation",
            "difficulty": "beginner",
            "question": "Complete the train-test split code:",
            "code_snippet": "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, ______=42)",
            "options": [
                "random_state",
                "shuffle",
                "seed",
                "random_seed"
            ],
            "correct_answer": 0,
            "explanation": "random_state ensures reproducible splits across different runs"
        },
        {
            "id": 7,
            "type": "conceptual",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "When comparing MAE and MSE, which statement is true?",
            "options": [
                "MSE penalizes larger errors more heavily than MAE",
                "MAE is always better than MSE",
                "MSE is not sensitive to outliers",
                "MAE squares the errors before averaging"
            ],
            "correct_answer": 0,
            "explanation": "MSE squares the errors, giving more weight to larger errors, while MAE treats all errors equally"
        },
        {
            "id": 8,
            "type": "error_debugging",
            "category": "data_preparation",
            "difficulty": "intermediate",
            "question": "What causes this KeyError and how to fix it?",
            "code_snippet": "X = df[['Age']]\ny = df['Credit Amount']  # KeyError: 'Credit Amount'",
            "options": [
                "Check actual column names using df.columns.tolist() and use exact names",
                "Use single quotes instead of double quotes",
                "The column doesn't exist in any dataset",
                "Use df.columns['Credit Amount'] instead"
            ],
            "correct_answer": 0,
            "explanation": "Column names are case-sensitive and space-sensitive. Always verify exact column names from the dataset"
        },
        {
            "id": 9,
            "type": "conceptual",
            "category": "model_evaluation",
            "difficulty": "advanced",
            "question": "What is the primary purpose of using cross-validation?",
            "options": [
                "To get a sense of whether the model will generalize well to unseen data",
                "To improve model training speed by using smaller data splits",
                "To increase the model's accuracy on the training set",
                "To reduce the number of input features in a dataset"
            ],
            "correct_answer": 0,
            "explanation": "Cross-validation helps estimate how well the model performs on unseen data by testing on multiple validation sets"
        },
        {
            "id": 10,
            "type": "best_practice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "When working with a DataFrame, why is it important to make a copy of the original data?",
            "options": [
                "It allows for testing and experimentation without altering the original dataset",
                "It increases the computational requirements",
                "It automatically categorizes data",
                "It reduces the need for data cleaning"
            ],
            "correct_answer": 0,
            "explanation": "Making a copy preserves data integrity and allows reverting to original data if needed"
        },
        {
            "id": 11,
            "type": "code_completion",
            "category": "model_training",
            "difficulty": "beginner",
            "question": "Complete the model training code:",
            "code_snippet": "model = LinearRegression()\nmodel.______(X_train, y_train)",
            "options": [
                "fit",
                "train",
                "learn",
                "predict"
            ],
            "correct_answer": 0,
            "explanation": "The fit() method trains the model on the training data"
        },
        {
            "id": 12,
            "type": "conceptual",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "In a confusion matrix for a rare disease prediction (100 out of 100,000 have disease), if a model classifies everyone as negative, what is the accuracy?",
            "options": [
                "~99%",
                "~50%",
                "~1%",
                "~0%"
            ],
            "correct_answer": 0,
            "explanation": "Accuracy = (TN + TP) / Total = (99,900 + 0) / 100,000 = 99.9%. This shows why accuracy alone can be misleading for imbalanced datasets."
        },
        {
            "id": 13,
            "type": "output_prediction",
            "category": "data_preparation",
            "difficulty": "beginner",
            "question": "What does df.head() display?",
            "options": [
                "The first 5 rows of the DataFrame",
                "The last 5 rows of the DataFrame",
                "Summary statistics of the DataFrame",
                "Column information and data types"
            ],
            "correct_answer": 0,
            "explanation": "df.head() shows the first 5 rows by default, useful for quick data inspection"
        },
        {
            "id": 14,
            "type": "conceptual",
            "category": "model_selection",
            "difficulty": "advanced",
            "question": "Given: Training Accuracy = 97%, Test Accuracy = 68%. What does this indicate?",
            "options": [
                "The model is overfitting",
                "The model is underfitting",
                "The model generalizes well",
                "The data is perfectly balanced"
            ],
            "correct_answer": 0,
            "explanation": "Large gap between training and test accuracy (29%) indicates overfitting - the model memorized training data but doesn't generalize"
        },
        {
            "id": 15,
            "type": "best_practice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "For a model predicting customer churn (binary classification), which loss function is appropriate?",
            "options": [
                "Binary Cross-Entropy",
                "Mean Squared Error",
                "Mean Absolute Error",
                "R-squared"
            ],
            "correct_answer": 0,
            "explanation": "Binary cross-entropy is designed for classification problems with two classes, while MSE is for regression"
        },
        {
            "id": 16,
            "type": "conceptual",
            "category": "advanced_metrics",
            "difficulty": "advanced",
            "question": "What is the key difference between R-squared and Adjusted R-squared?",
            "options": [
                "Adjusted R-squared penalizes for adding unnecessary variables",
                "R-squared works better for multiple regression",
                "Adjusted R-squared is always higher than R-squared",
                "R-squared is only for simple linear regression"
            ],
            "correct_answer": 0,
            "explanation": "Adjusted R-squared adjusts for the number of predictors in the model, preventing overfitting by penalizing irrelevant variables"
        },
        {
            "id": 17,
            "type": "code_completion",
            "category": "advanced_metrics",
            "difficulty": "advanced",
            "question": "Complete the Adjusted R-squared calculation formula:",
            "code_snippet": "adjusted_r_squared = 1 - (1 - r_squared) * (len(y_test) - 1) / (len(y_test) - X_test.shape[1] - ______)",
            "options": [
                "1",
                "0",
                "2",
                "X_test.shape[0]"
            ],
            "correct_answer": 0,
            "explanation": "The formula is: 1 - (1 - RÂ²) * (n - 1) / (n - k - 1) where n = sample size, k = number of features"
        },
        {
            "id": 18,
            "type": "conceptual",
            "category": "multiple_regression",
            "difficulty": "intermediate",
            "question": "When building a multiple linear regression model with Product Price, Advertising Expenditure, and Discount Percentage as features, what does this approach allow?",
            "options": [
                "Analyzing the combined impact of multiple factors on sales",
                "Reducing the model training time",
                "Eliminating the need for train-test split",
                "Guaranteeing perfect predictions"
            ],
            "correct_answer": 0,
            "explanation": "Multiple regression captures how several independent variables collectively influence the dependent variable"
        },
        {
            "id": 19,
            "type": "code_completion",
            "category": "multiple_regression",
            "difficulty": "intermediate",
            "question": "Complete the code for multiple feature selection:",
            "code_snippet": "X = df[['Product Price', 'Advertising Expenditure', '______']]",
            "options": [
                "Discount Percentage",
                "Sales",
                "Age",
                "Income"
            ],
            "correct_answer": 0,
            "explanation": "All three features (Product Price, Advertising Expenditure, Discount Percentage) should be included as predictors for Sales"
        },
        {
            "id": 20,
            "type": "conceptual",
            "category": "encoding",
            "difficulty": "intermediate",
            "question": "What is the key difference between One-Hot Encoding and Label Encoding?",
            "options": [
                "One-Hot creates binary columns for each category; Label assigns integer values",
                "Label Encoding is only for numerical data",
                "One-Hot Encoding works only for binary classification",
                "Label Encoding is always better for linear regression"
            ],
            "correct_answer": 0,
            "explanation": "One-Hot Encoding creates separate binary columns for each category, while Label Encoding assigns integer values (0,1,2...) which may imply ordinal relationships"
        },
        {
            "id": 21,
            "type": "code_completion",
            "category": "encoding",
            "difficulty": "intermediate",
            "question": "Complete the One-Hot Encoding code using scikit-learn:",
            "code_snippet": "encoder = ______()\nX_encoded = encoder.fit_transform(X)",
            "options": [
                "OneHotEncoder",
                "LabelEncoder",
                "get_dummies",
                "CategoryEncoder"
            ],
            "correct_answer": 0,
            "explanation": "OneHotEncoder from sklearn.preprocessing is used for one-hot encoding categorical variables"
        },
        {
            "id": 22,
            "type": "code_completion",
            "category": "encoding",
            "difficulty": "intermediate",
            "question": "Complete the Label Encoding code:",
            "code_snippet": "label_encoder = LabelEncoder()\nencoded_job = label_encoder.______(df['Job'])",
            "options": [
                "fit_transform",
                "transform",
                "encode",
                "fit"
            ],
            "correct_answer": 0,
            "explanation": "fit_transform both learns the encoding mapping and applies it to the data"
        },
        {
            "id": 23,
            "type": "error_debugging",
            "category": "encoding",
            "difficulty": "intermediate",
            "question": "Why does this Label Encoding code need reshaping?",
            "code_snippet": "encoded_job = label_encoder.fit_transform(df['Job'])\nX = encoded_job  # Error when fitting model",
            "options": [
                "scikit-learn requires 2D input; use encoded_job.reshape(-1, 1)",
                "Label Encoding cannot be used with linear regression",
                "The encoded values should be converted to strings",
                "One-Hot Encoding should be used instead"
            ],
            "correct_answer": 0,
            "explanation": "scikit-learn expects features as 2D arrays. Reshape from (n,) to (n,1) using .reshape(-1, 1)"
        },
        {
            "id": 24,
            "type": "conceptual",
            "category": "train_test_split",
            "difficulty": "intermediate",
            "question": "What is the purpose of random_state in train_test_split?",
            "options": [
                "Ensures reproducible splits across different runs",
                "Improves model accuracy",
                "Reduces training time",
                "Automatically selects the best split ratio"
            ],
            "correct_answer": 0,
            "explanation": "random_state ensures that the data splitting is consistent across different executions, making results reproducible"
        },
        {
            "id": 25,
            "type": "best_practice",
            "category": "train_test_split",
            "difficulty": "intermediate",
            "question": "When comparing 70:30 vs 80:20 train-test splits, which statement is true?",
            "options": [
                "80:20 provides more training data but less reliable evaluation",
                "70:30 is always better for all datasets",
                "The choice depends on dataset size and model complexity",
                "Split ratio doesn't affect model performance"
            ],
            "correct_answer": 2,
            "explanation": "The optimal split ratio depends on dataset size - larger datasets can use smaller test sets, while smaller datasets need larger test sets for reliable evaluation"
        },
        {
            "id": 26,
            "type": "conceptual",
            "category": "model_evaluation",
            "difficulty": "advanced",
            "question": "In the scenario with Model A (RMSE=500, MAPE=4%) vs Model B (RMSE=300, MAPE=15%) for products with different volumes, which model is better for business use?",
            "options": [
                "Model A - Lower MAPE ensures better percentage accuracy across different product volumes",
                "Model B - Lower RMSE is always better for inventory optimization",
                "Model B - It performs better for high-volume products which generate more revenue",
                "Neither - Both models need improvement"
            ],
            "correct_answer": 0,
            "explanation": "MAPE (percentage error) provides fair comparison across different scales, making Model A more reliable for both low-volume and high-volume products"
        },
        {
            "id": 27,
            "type": "conceptual",
            "category": "data_filtering",
            "difficulty": "intermediate",
            "question": "When filtering data for 'female' applicants with 'skilled' jobs before modeling, what potential issue arises?",
            "options": [
                "Limited variation in features after filtering may reduce predictive power",
                "The model will overfit due to too much data",
                "Linear regression cannot handle filtered datasets",
                "Filtering improves model accuracy automatically"
            ],
            "correct_answer": 0,
            "explanation": "Filtering to specific categories reduces data diversity and feature variation, which can limit the model's ability to find meaningful patterns"
        },
        {
            "id": 28,
            "type": "code_completion",
            "category": "data_filtering",
            "difficulty": "intermediate",
            "question": "Complete the boolean filtering code:",
            "code_snippet": "filtered_df = df[(df['Sex'] == 'female') & (df['______'] == 'skilled')]",
            "options": [
                "Job",
                "Occupation",
                "Skill",
                "Type"
            ],
            "correct_answer": 0,
            "explanation": "The filter selects records where both conditions are true: Sex is 'female' AND Job is 'skilled'"
        },
        {
            "id": 29,
            "type": "conceptual",
            "category": "regression_theory",
            "difficulty": "advanced",
            "question": "If a regression line perfectly fits the training data, which statement is correct?",
            "options": [
                "The regression line passes through all training data points",
                "The model will also perfectly fit test data",
                "The model is guaranteed to generalize well",
                "R-squared will be exactly 0"
            ],
            "correct_answer": 0,
            "explanation": "Perfect fit on training data means zero training error (line passes through all points), but this often indicates overfitting and poor generalization"
        },
        {
            "id": 30,
            "type": "best_practice",
            "category": "model_interpretation",
            "difficulty": "intermediate",
            "question": "When a regression line shows most data points above it (like in Model A from the document), what does this indicate?",
            "options": [
                "The model is systematically under-predicting the target variable",
                "The model has high variance",
                "The features are perfectly correlated",
                "The model is overfitting to noise"
            ],
            "correct_answer": 0,
            "explanation": "When most points are above the regression line, the model consistently predicts lower values than actual - indicating systematic bias in under-prediction"
        },
        {
            "id": 31,
            "type": "conceptual",
            "category": "business_application",
            "difficulty": "intermediate",
            "question": "In lead scoring (identifying high-value leads), if a model correctly identifies most high-value leads but misses some, what should be improved?",
            "options": [
                "Recall - to capture more of the actual high-value leads",
                "Precision - the model is too lenient",
                "Accuracy - overall performance is poor",
                "Specificity - too many false positives"
            ],
            "correct_answer": 0,
            "explanation": "Missing actual high-value leads means low recall. Improving recall would help capture more of the valuable leads the model is currently missing"
        },
        {
            "id": 32,
            "type": "code_completion",
            "category": "advanced_metrics",
            "difficulty": "advanced",
            "question": "Complete the code to calculate both R-squared and Adjusted R-squared:",
            "code_snippet": "r_squared = model.score(X_test, y_test)\nadj_r_squared = 1 - (1 - r_squared) * (len(y_test) - 1) / (len(y_test) - X_test.shape[1] - ______)",
            "options": [
                "1",
                "0",
                "2",
                "r_squared"
            ],
            "correct_answer": 0,
            "explanation": "The adjusted R-squared formula uses (n - k - 1) in denominator, where n = sample size, k = number of features"
        },
        {
            "id": 33,
            "type": "conceptual",
            "category": "feature_engineering",
            "difficulty": "advanced",
            "question": "Why might Adjusted R-squared be more useful than R-squared when comparing models with different numbers of features?",
            "options": [
                "It penalizes model complexity, preventing overfitting",
                "It's always higher than R-squared",
                "It works better with categorical data",
                "It requires less computational power"
            ],
            "correct_answer": 0,
            "explanation": "Adjusted R-squared accounts for the number of predictors, making it better for comparing models with different complexity levels"
        },
        {
            "id": 34,
            "type": "best_practice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "When encountering KeyError with column names, what's the recommended first step?",
            "options": [
                "Print df.columns.tolist() to see actual column names",
                "Try different case variations of the column name",
                "Assume the column doesn't exist and skip it",
                "Use integer indexing instead of column names"
            ],
            "correct_answer": 0,
            "explanation": "Always verify the exact column names in your dataset as they are case-sensitive and space-sensitive"
        },
        {
            "id": 35,
            "type": "conceptual",
            "category": "model_selection",
            "difficulty": "advanced",
            "question": "What does a small gap between training and test accuracy indicate?",
            "options": [
                "The model generalizes well to unseen data",
                "The model is underfitting the training data",
                "The test set is too similar to training set",
                "The model needs more complex features"
            ],
            "correct_answer": 0,
            "explanation": "Small performance gap between training and test sets suggests good generalization - the model learned patterns rather than memorizing data"
        },
        {
            "id": 36,
            "type": "code_completion",
            "category": "imports",
            "difficulty": "beginner",
            "question": "Complete the import statement for reading CSV files:",
            "code_snippet": "import ______ as pd",
            "options": [
                "pandas",
                "numpy",
                "sklearn",
                "csv"
            ],
            "correct_answer": 0,
            "explanation": "pandas is imported as pd by convention and provides read_csv() function"
        },
        {
            "id": 37,
            "type": "code_completion",
            "category": "data_loading",
            "difficulty": "beginner",
            "question": "Complete the code to read a CSV file:",
            "code_snippet": "df = pd.______('data.csv')",
            "options": [
                "read_csv",
                "read_csv_file",
                "load_csv",
                "import_csv"
            ],
            "correct_answer": 0,
            "explanation": "pd.read_csv() is the standard pandas function for reading CSV files"
        },
        {
            "id": 38,
            "type": "conceptual",
            "category": "basic_concepts",
            "difficulty": "beginner",
            "question": "What is the purpose of the fit() method in scikit-learn?",
            "options": [
                "To train the model on the provided data",
                "To make predictions on new data",
                "To evaluate model performance",
                "To split the data into training and test sets"
            ],
            "correct_answer": 0,
            "explanation": "The fit() method trains the model by learning patterns from the training data"
        },
        {
            "id": 39,
            "type": "code_completion",
            "category": "predictions",
            "difficulty": "beginner",
            "question": "Complete the code to make predictions:",
            "code_snippet": "y_pred = model.______(X_test)",
            "options": [
                "predict",
                "fit",
                "transform",
                "score"
            ],
            "correct_answer": 0,
            "explanation": "The predict() method uses the trained model to make predictions on new data"
        },
        {
            "id": 40,
            "type": "conceptual",
            "category": "basic_concepts",
            "difficulty": "beginner",
            "question": "What does the predict() method return?",
            "options": [
                "Predicted values for the input data",
                "Model accuracy score",
                "Training loss values",
                "Feature importance scores"
            ],
            "correct_answer": 0,
            "explanation": "predict() returns the model's predictions for the input features"
        },
        {
            "id": 41,
            "type": "error_debugging",
            "category": "data_types",
            "difficulty": "beginner",
            "question": "Why might this code fail with a ValueError?",
            "code_snippet": "X = df['Age']  # Series (1D)\nmodel.fit(X, y)",
            "options": [
                "X should be 2D; use X = df[['Age']]",
                "y should also be 2D",
                "Age column contains strings",
                "The model is not initialized"
            ],
            "correct_answer": 0,
            "explanation": "scikit-learn expects features as 2D arrays. Single brackets return Series (1D), double brackets return DataFrame (2D)"
        },
        {
            "id": 42,
            "type": "code_completion",
            "category": "metrics",
            "difficulty": "beginner",
            "question": "Complete the code to calculate Mean Absolute Error:",
            "code_snippet": "from sklearn.metrics import ______\nmae = ______(y_test, y_pred)",
            "options": [
                "mean_absolute_error",
                "mae",
                "absolute_error",
                "mean_error"
            ],
            "correct_answer": 0,
            "explanation": "mean_absolute_error is the correct function name from sklearn.metrics"
        },
        {
            "id": 43,
            "type": "conceptual",
            "category": "basic_concepts",
            "difficulty": "beginner",
            "question": "What is the role of the target variable (y) in supervised learning?",
            "options": [
                "The variable we want to predict",
                "The input features for prediction",
                "The model parameters",
                "The evaluation metric"
            ],
            "correct_answer": 0,
            "explanation": "The target variable (y) is what we're trying to predict based on the feature variables (X)"
        },
        {
            "id": 44,
            "type": "code_completion",
            "category": "model_evaluation",
            "difficulty": "beginner",
            "question": "Complete the code to print the R-squared value:",
            "code_snippet": "print(f\"R-squared: {______:.4f}\")",
            "options": [
                "r_squared",
                "r2",
                "score",
                "accuracy"
            ],
            "correct_answer": 0,
            "explanation": "Use the variable name where you stored the R-squared value, typically 'r_squared'"
        },
        {
            "id": 45,
            "type": "conceptual",
            "category": "data_inspection",
            "difficulty": "beginner",
            "question": "What information does df.info() provide?",
            "options": [
                "Column names, data types, and non-null counts",
                "First 5 rows of the DataFrame",
                "Statistical summary of numerical columns",
                "Correlation between variables"
            ],
            "correct_answer": 0,
            "explanation": "df.info() shows the DataFrame's structure including column names, data types, and memory usage"
        },
        {
            "id": 46,
            "type": "best_practice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "When should you use train_test_split with stratification?",
            "options": [
                "When you have imbalanced classes in classification problems",
                "Always, for every machine learning problem",
                "Only for regression problems",
                "When your dataset is very large"
            ],
            "correct_answer": 0,
            "explanation": "Stratification ensures that the train and test sets have the same proportion of classes as the original dataset, crucial for imbalanced data"
        },
        {
            "id": 47,
            "type": "conceptual",
            "category": "model_interpretation",
            "difficulty": "intermediate",
            "question": "What does a negative R-squared value indicate?",
            "options": [
                "The model performs worse than a horizontal line (mean predictor)",
                "There's an error in the calculation",
                "The model has perfect predictions",
                "The data is normally distributed"
            ],
            "correct_answer": 0,
            "explanation": "Negative R-squared means the model is worse than simply predicting the mean of the target variable"
        },
        {
            "id": 48,
            "type": "code_completion",
            "category": "multiple_regression",
            "difficulty": "intermediate",
            "question": "Complete the code for multiple regression with two features:",
            "code_snippet": "X = df[['Product Price', '______']]",
            "options": [
                "Advertising Expenditure",
                "Sales",
                "Age",
                "Discount"
            ],
            "correct_answer": 0,
            "explanation": "Both 'Product Price' and 'Advertising Expenditure' are features; 'Sales' would be the target variable"
        },
        {
            "id": 49,
            "type": "error_debugging",
            "category": "imports",
            "difficulty": "intermediate",
            "question": "What's wrong with this import statement?",
            "code_snippet": "from sklearn.Linear_model import LinearRegression",
            "options": [
                "Linear_model should be linear_model (lowercase L)",
                "Should import from sklearn.regression instead",
                "Need to import pandas first",
                "LinearRegression is not in sklearn"
            ],
            "correct_answer": 0,
            "explanation": "scikit-learn uses lowercase module names: from sklearn.linear_model import LinearRegression"
        },
        {
            "id": 50,
            "type": "conceptual",
            "category": "feature_selection",
            "difficulty": "intermediate",
            "question": "Why might you use feature engineering before linear regression?",
            "options": [
                "To create better features that have linear relationships with the target",
                "To reduce the dataset size for faster training",
                "To eliminate the need for train-test split",
                "To automatically handle missing values"
            ],
            "correct_answer": 0,
            "explanation": "Feature engineering can create transformed features that have stronger linear relationships with the target variable"
        },
        {
            "id": 51,
            "type": "best_practice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "When comparing models, why look at both training and test performance?",
            "options": [
                "To detect overfitting (good training performance but poor test performance)",
                "To calculate the exact model parameters",
                "To determine the optimal learning rate",
                "To select the best activation function"
            ],
            "correct_answer": 0,
            "explanation": "Comparing training vs test performance helps identify overfitting - when a model memorizes training data but fails to generalize"
        },
        {
            "id": 52,
            "type": "code_completion",
            "category": "data_validation",
            "difficulty": "intermediate",
            "question": "Complete the code to check for missing values:",
            "code_snippet": "missing_values = df.______()",
            "options": [
                "isnull",
                "isna",
                "missing",
                "null"
            ],
            "correct_answer": 0,
            "explanation": "df.isnull() returns a DataFrame indicating which values are missing (NaN)"
        },
        {
            "id": 53,
            "type": "conceptual",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "What is the purpose of scaling features in linear regression?",
            "options": [
                "To ensure all features contribute equally regardless of their scale",
                "To reduce the number of features",
                "To convert categorical features to numerical",
                "To handle missing values automatically"
            ],
            "correct_answer": 0,
            "explanation": "Feature scaling prevents features with large scales from dominating the model, especially important for regularization"
        },
        {
            "id": 54,
            "type": "error_debugging",
            "category": "predictions",
            "difficulty": "intermediate",
            "question": "Why might predictions be exactly the same for all test samples?",
            "options": [
                "The model is predicting the mean (underfitting)",
                "The test data is identical to training data",
                "The random_state parameter is set incorrectly",
                "The model is overfitting perfectly"
            ],
            "correct_answer": 0,
            "explanation": "Constant predictions often indicate the model failed to learn meaningful patterns and is just predicting the average target value"
        },
        {
            "id": 55,
            "type": "conceptual",
            "category": "model_interpretation",
            "difficulty": "intermediate",
            "question": "What does the coefficient in linear regression represent?",
            "options": [
                "The change in target variable for a one-unit change in the feature",
                "The probability of correct prediction",
                "The model's accuracy score",
                "The correlation between features"
            ],
            "correct_answer": 0,
            "explanation": "Each coefficient represents the expected change in the target variable for a one-unit change in that feature, holding other features constant"
        },
        {
            "id": 56,
            "type": "conceptual",
            "category": "advanced_metrics",
            "difficulty": "advanced",
            "question": "When would you prefer MAPE over RMSE for model evaluation?",
            "options": [
                "When you need percentage errors that are comparable across different scales",
                "When you want to penalize large errors more heavily",
                "When working with binary classification problems",
                "When your data follows a perfect normal distribution"
            ],
            "correct_answer": 0,
            "explanation": "MAPE provides relative error percentages, making it useful for comparing model performance across datasets with different scales"
        },
        {
            "id": 57,
            "type": "code_completion",
            "category": "cross_validation",
            "difficulty": "advanced",
            "question": "Complete the code for k-fold cross-validation:",
            "code_snippet": "from sklearn.model_selection import ______\ncv_scores = ______(model, X, y, cv=5)",
            "options": [
                "cross_val_score",
                "kfold_score",
                "cross_validate",
                "validate_model"
            ],
            "correct_answer": 0,
            "explanation": "cross_val_score performs k-fold cross-validation and returns scores for each fold"
        },
        {
            "id": 58,
            "type": "conceptual",
            "category": "regularization",
            "difficulty": "advanced",
            "question": "What is the purpose of regularization in linear regression?",
            "options": [
                "To prevent overfitting by penalizing large coefficients",
                "To increase model training speed",
                "To handle categorical variables automatically",
                "To ensure perfect fit on training data"
            ],
            "correct_answer": 0,
            "explanation": "Regularization adds a penalty term to the loss function to discourage complex models and reduce overfitting"
        },
        {
            "id": 59,
            "type": "best_practice",
            "category": "model_selection",
            "difficulty": "advanced",
            "question": "When should you use Ridge regression over Ordinary Least Squares?",
            "options": [
                "When you have multicollinearity among features",
                "When your dataset is very small",
                "When you need the fastest possible training",
                "When all features are perfectly independent"
            ],
            "correct_answer": 0,
            "explanation": "Ridge regression handles multicollinearity by penalizing correlated features, providing more stable coefficient estimates"
        },
        {
            "id": 60,
            "type": "conceptual",
            "category": "assumptions",
            "difficulty": "advanced",
            "question": "What is the homoscedasticity assumption in linear regression?",
            "options": [
                "Constant variance of errors across all prediction levels",
                "Linear relationship between features and target",
                "Normally distributed errors",
                "No perfect multicollinearity between features"
            ],
            "correct_answer": 0,
            "explanation": "Homoscedasticity means the variance of the errors is constant across all values of the independent variables"
        },
        {
            "id": 61,
            "type": "code_completion",
            "category": "pipeline",
            "difficulty": "advanced",
            "question": "Complete the code to create a preprocessing and modeling pipeline:",
            "code_snippet": "from sklearn.pipeline import ______\nfrom sklearn.preprocessing import StandardScaler",
            "options": [
                "Pipeline",
                "ModelPipeline",
                "SKPipeline",
                "LinearPipeline"
            ],
            "correct_answer": 0,
            "explanation": "Pipeline chains multiple processing steps together, such as scaling followed by regression"
        },
        {
            "id": 62,
            "type": "conceptual",
            "category": "bias_variance",
            "difficulty": "advanced",
            "question": "In the bias-variance tradeoff, what does high bias indicate?",
            "options": [
                "The model is too simple and underfits the data",
                "The model is too complex and overfits the data",
                "The training data is insufficient",
                "The features are poorly scaled"
            ],
            "correct_answer": 0,
            "explanation": "High bias means the model makes strong assumptions about the data and is too simple to capture underlying patterns (underfitting)"
        },
        {
            "id": 63,
            "type": "best_practice",
            "category": "feature_engineering",
            "difficulty": "advanced",
            "question": "When creating polynomial features for linear regression, what risk increases?",
            "options": [
                "Overfitting due to increased model complexity",
                "Underfitting from too many features",
                "Training time decreases exponentially",
                "Model interpretability improves dramatically"
            ],
            "correct_answer": 0,
            "explanation": "Polynomial features increase model flexibility but can lead to overfitting, especially with high-degree polynomials"
        },
        {
            "id": 64,
            "type": "conceptual",
            "category": "model_diagnostics",
            "difficulty": "advanced",
            "question": "What pattern in residual plots indicates heteroscedasticity?",
            "options": [
                "Fan-shaped spread of residuals (increasing variance)",
                "Straight horizontal line of residuals",
                "U-shaped curve of residuals",
                "Random scatter with constant spread"
            ],
            "correct_answer": 0,
            "explanation": "Heteroscedasticity appears as a fan shape in residual plots, where error variance changes with predicted values"
        },
        {
            "id": 65,
            "type": "code_completion",
            "category": "advanced_evaluation",
            "difficulty": "advanced",
            "question": "Complete the code for calculating multiple metrics:",
            "code_snippet": "from sklearn.metrics import ______, mean_squared_error, r2_score",
            "options": [
                "mean_absolute_error",
                "accuracy_score",
                "f1_score",
                "precision_score"
            ],
            "correct_answer": 0,
            "explanation": "For regression problems, common metrics include MAE, MSE, and R-squared from sklearn.metrics"
        },
        {
            "id": 66,
            "type": "conceptual",
            "category": "business_applications",
            "difficulty": "advanced",
            "question": "In a business context, why might you prefer a slightly less accurate but more interpretable model?",
            "options": [
                "To build trust and enable actionable insights from coefficients",
                "To reduce computational costs",
                "To comply with data privacy regulations",
                "To make the model training faster"
            ],
            "correct_answer": 0,
            "explanation": "Interpretable models allow stakeholders to understand relationships and make data-driven decisions, which is often more valuable than marginal accuracy gains"
        },
        {
            "id": 67,
            "type": "best_practice",
            "category": "deployment",
            "difficulty": "advanced",
            "question": "What is the purpose of saving a trained model with joblib or pickle?",
            "options": [
                "To reuse the model without retraining for future predictions",
                "To improve model accuracy on new data",
                "To reduce the model's memory footprint",
                "To automatically update the model with new data"
            ],
            "correct_answer": 0,
            "explanation": "Model serialization allows you to save the trained model and load it later for making predictions without going through the training process again"
        },
        {
            "id": 68,
            "type": "conceptual",
            "category": "assumptions",
            "difficulty": "advanced",
            "question": "What is the consequence of violating the linearity assumption in linear regression?",
            "options": [
                "The model will have systematic prediction errors and poor performance",
                "The model will automatically correct for non-linearity",
                "The R-squared value becomes meaningless",
                "The training process will fail completely"
            ],
            "correct_answer": 0,
            "explanation": "If the true relationship is non-linear, a linear model will consistently mispredict, leading to biased estimates and poor performance"
        },
        {
            "id": 69,
            "type": "code_completion",
            "category": "model_persistence",
            "difficulty": "advanced",
            "question": "Complete the code to save a trained model:",
            "code_snippet": "import joblib\njoblib.______(model, 'linear_model.pkl')",
            "options": [
                "dump",
                "save",
                "export",
                "write"
            ],
            "correct_answer": 0,
            "explanation": "joblib.dump() saves the model to a file, which can be loaded later with joblib.load()"
        },
        {
            "id": 70,
            "type": "conceptual",
            "category": "advanced_topics",
            "difficulty": "advanced",
            "question": "What is the key advantage of using ElasticNet over Ridge or Lasso regression?",
            "options": [
                "It combines both L1 and L2 regularization for feature selection and handling correlated features",
                "It trains faster than both Ridge and Lasso",
                "It doesn't require feature scaling",
                "It automatically detects non-linear relationships"
            ],
            "correct_answer": 0,
            "explanation": "ElasticNet combines the benefits of both Lasso (feature selection) and Ridge (handling correlated features) regularization"
        },
        {
            "id": 71,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "Which of the following is NOT considered a core machine learning technique?",
            "options": [
                "Supervised learning",
                "Rule-based model",
                "Reinforcement learning",
                "Unsupervised learning"
            ],
            "correct_answer": 1,
            "explanation": "Rule-based models rely on explicitly defined human-created rules rather than learning patterns from data, making them distinct from true machine learning techniques like supervised, unsupervised, and reinforcement learning."
        },
        {
            "id": 72,
            "type": "multiple_choice",
            "category": "regression_basics",
            "difficulty": "beginner",
            "question": "What is the main goal when building a regression model to predict house prices from size?",
            "options": [
                "To find a relationship that can predict prices for houses not in the dataset",
                "To memorize the exact price of every house in the dataset",
                "To identify the largest house in the dataset",
                "To remove houses with low prices from the dataset"
            ],
            "correct_answer": 0,
            "explanation": "Regression models aim to generalize patterns from training data to make accurate predictions on new, unseen data - not to memorize the training examples."
        },
        {
            "id": 73,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "beginner",
            "question": "Why is it important to agree on a definition of the 'best' model?",
            "options": [
                "So that everyone writes the same code",
                "Because one model is always the best in every situation",
                "To enable consistent communication and evaluation",
                "To make visualizations more appealing"
            ],
            "correct_answer": 2,
            "explanation": "Agreeing on evaluation criteria ensures objective model comparison, consistent decision-making, and reproducible results across team members or researchers."
        },
        {
            "id": 74,
            "type": "multiple_choice",
            "category": "linear_regression_basics",
            "difficulty": "beginner",
            "question": "How is the 'best' line determined in linear regression?",
            "options": [
                "By maximizing the total error between predicted and actual values",
                "By fitting the line to the training data exactly, without any errors",
                "By randomly guessing parameters and adjusting them to minimize errors",
                "By making the total of all squared differences between predicted and actual values as small as possible"
            ],
            "correct_answer": 3,
            "explanation": "Linear regression uses Ordinary Least Squares (OLS) to find the line that minimizes the sum of squared differences between predicted and actual values, providing the best overall fit to the data pattern."
        },
        {
            "id": 75,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the main purpose of building a mathematical model using data?",
            "options": [
                "Memorize all the data exactly",
                "Eliminate all variation in the data",
                "Predict new or future outcomes based on past patterns",
                "Draw an accurate graph"
            ],
            "correct_answer": 2,
            "explanation": "The goal of modeling is to generalize from existing data to make accurate predictions or decisions about new, unseen situations - capturing patterns rather than memorizing specifics."
        },
        {
            "id": 76,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "How is supervised learning different from unsupervised learning?",
            "options": [
                "Supervised learning uses a known target (Y) to guide the model; unsupervised learning does not",
                "Unsupervised learning uses labels, while supervised learning does not",
                "There is no difference; both are the same",
                "Supervised learning does not use data, while unsupervised learning does"
            ],
            "correct_answer": 0,
            "explanation": "Supervised learning has a 'teacher' (known target/label) where data includes both input and correct answer, while unsupervised learning has no teacher and looks for hidden patterns without predefined answers."
        },
        {
            "id": 77,
            "type": "multiple_choice",
            "category": "regression_basics",
            "difficulty": "beginner",
            "question": "Which of the following use cases is ideal for applying a linear regression model?",
            "options": [
                "Predicting a customer's total spend based on their income",
                "Predicting whether a customer will buy a product (Yes/No)",
                "Predicting the most popular product category among customers",
                "Grouping customers based on purchasing behavior"
            ],
            "correct_answer": 0,
            "explanation": "Linear regression is used for predicting continuous numerical values like total spend. The other options involve categorical outcomes or clustering, which require different techniques."
        },
        {
            "id": 78,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is a key characteristic of unsupervised learning?",
            "options": [
                "It uses labeled data to create predictions",
                "It requires that the data have a continuous output",
                "There is no dependent variable to predict; the goal is to discover patterns in the data",
                "The model is guided by a known target variable"
            ],
            "correct_answer": 2,
            "explanation": "Unsupervised learning works with unlabeled data to discover hidden structures like groupings or patterns, without predicting a specific target variable."
        },
        {
            "id": 79,
            "type": "multiple_choice",
            "category": "ensemble_learning",
            "difficulty": "intermediate",
            "question": "How does ensemble learning improve model performance?",
            "options": [
                "By training only one model with the highest accuracy",
                "By using simpler models and ignoring complex ones",
                "By training models without any data",
                "By using multiple models and combining their predictions to improve accuracy"
            ],
            "correct_answer": 3,
            "explanation": "Ensemble learning combines predictions from multiple models, reducing individual model errors and providing more reliable results through methods like voting or averaging."
        },
        {
            "id": 80,
            "type": "multiple_choice",
            "category": "data_quality",
            "difficulty": "intermediate",
            "question": "What is the main difference between 'information' and 'noise' in a dataset?",
            "options": [
                "Noise is essential for training models; information is discarded",
                "Noise is always visible in visualizations; information is hidden",
                "Information leads to overfitting; noise prevents it",
                "Information is generally consistent and predictable; noise is random and unpredictable"
            ],
            "correct_answer": 3,
            "explanation": "Information represents true underlying patterns that help predictions, while noise consists of random fluctuations that don't follow meaningful patterns and can lead to overfitting."
        },
        {
            "id": 81,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What does it mean when a model is said to be overfitting?",
            "options": [
                "It learns both real patterns and random noise, which can hurt its performance on new data",
                "It completely ignores all patterns and noise in the data",
                "It is too simple and misses important patterns in the data",
                "It is perfect and will always perform well on any future data"
            ],
            "correct_answer": 0,
            "explanation": "Overfitting occurs when a model becomes too complex and memorizes training data specifics, including noise, leading to poor performance on new, unseen data."
        },
        {
            "id": 82,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "beginner",
            "question": "What is the role of a loss function in model evaluation?",
            "options": [
                "To visualize model predictions",
                "To split data into training and test sets",
                "To remove noise from the data",
                "To measure how accurate or wrong a model's predictions are"
            ],
            "correct_answer": 3,
            "explanation": "A loss function acts as a 'mistake meter' that measures prediction errors during training, helping the model adjust and improve its accuracy."
        },
        {
            "id": 83,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "Why should the final model selection be based only on test data performance, not training data?",
            "options": [
                "Because test data always gives better accuracy",
                "Because training data is used to teach the model and may not reflect future performance",
                "Because training data is more expensive to compute",
                "Because test data is always cleaner"
            ],
            "correct_answer": 1,
            "explanation": "Training data can be memorized (overfitting), while test data provides an honest assessment of how the model will perform on new, unseen data in real-world applications."
        },
        {
            "id": 84,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "Which of the following is NOT an evaluation metric or loss function commonly used for a regression task?",
            "options": [
                "F1 Score",
                "Mean Squared Error (MSE)",
                "Mean Absolute Error (MAE)",
                "Root Mean Squared Error (RMSE)"
            ],
            "correct_answer": 0,
            "explanation": "F1 Score is used for classification tasks to combine precision and recall. MSE, MAE, and RMSE are all common regression metrics for continuous numerical predictions."
        },
        {
            "id": 85,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "In a confusion matrix of a binary classification problem, what does a False Negative (FN) represent?",
            "options": [
                "The model predicted positive, but the actual label was negative",
                "The model predicted negative, but the actual label was positive",
                "The model predicted positive, and it was correct",
                "The model predicted negative, and it was correct"
            ],
            "correct_answer": 1,
            "explanation": "A False Negative occurs when the model incorrectly predicts 'negative' for an actual positive case, representing a missed detection that can be serious in applications like medical testing."
        },
        {
            "id": 86,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "What is the main reason accuracy can be misleading for imbalanced classification problems?",
            "options": [
                "It is based on training data only",
                "A model can achieve high accuracy by only predicting the majority class",
                "It requires probabilities, not predictions",
                "It does consider false positives but ignores false negatives"
            ],
            "correct_answer": 1,
            "explanation": "With imbalanced data, a naive model that always predicts the majority class can achieve high accuracy while completely failing to identify the important minority class."
        },
        {
            "id": 87,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "After performing k-fold cross-validation, how do we typically report the model's performance?",
            "options": [
                "Take the average of the success measures across all folds",
                "Use the result from the first fold only",
                "Use the fold with the best performance",
                "Use the results from the training data"
            ],
            "correct_answer": 0,
            "explanation": "Averaging performance across all folds provides the most reliable and stable estimate of how the model will perform on new data, reducing the impact of any particular data split."
        },
        {
            "id": 88,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What is the main purpose of cross-validation in machine learning?",
            "options": [
                "To make the model more complex",
                "To avoid using test data",
                "To reduce the number of features",
                "To use all the data for both training and testing (at different times), improving reliability"
            ],
            "correct_answer": 3,
            "explanation": "Cross-validation rotates data through training and testing roles, providing better performance estimates without wasting data and giving more confidence in model selection."
        },
        {
            "id": 89,
            "type": "true_false",
            "category": "python_basics",
            "difficulty": "beginner",
            "question": "The str.isdigit() function checks whether the string is made up of digits and returns True or False accordingly.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "str.isdigit() returns True only if every character in the string is a digit (0-9), and False if there are any letters, spaces, punctuation, or empty strings."
        },
        {
            "id": 90,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What will be the output of the following code: cData = cData.replace('?', np.nan)",
            "options": [
                "It will show error",
                "It will replace missing values with '?'",
                "It will replace '?' with np.nan (NaN)",
                "It will replace np.nan (NaN) with '?'"
            ],
            "correct_answer": 2,
            "explanation": "This code replaces all occurrences of the string '?' with np.nan values, which is a common data cleaning operation to convert placeholder missing values to proper NaN representation."
        },
        {
            "id": 91,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "Which of the following code correctly converts the column 'horsepower' to float type?",
            "options": [
                "cData['horsepower'] = cData['horsepower'].astype(float)",
                "cData['horsepower'] = cData.astype(float)",
                "cData['horsepower'] = cData['horsepower'].astype(int)",
                "cData['horsepower'] = cData.astype(int)"
            ],
            "correct_answer": 0,
            "explanation": "The correct syntax targets only the 'horsepower' column and converts it specifically to float type using .astype(float)."
        },
        {
            "id": 92,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "What is the output of the following code: Filler = lambda x: x.fillna(x.median()); cData = cData.apply(Filler, axis=0)",
            "options": [
                "It will replace missing values of every column with its median",
                "It will replace missing values of every column with its mean",
                "It will show error",
                "It will show only those observations which are greater than median of the column"
            ],
            "correct_answer": 0,
            "explanation": "The code creates a lambda function that fills missing values with each column's median, then applies it to all columns (axis=0), effectively replacing NaN values with their respective column medians."
        },
        {
            "id": 93,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "When we set drop_first=True in pd.get_dummies(), which dummy variable is dropped?",
            "options": [
                "The last one of all dummy variables arranged in alphabetical order",
                "The first one of all dummy variables arranged in alphabetical order",
                "The middle one of all dummy variables arranged in alphabetical order",
                "Any randomly chosen dummy variable"
            ],
            "correct_answer": 1,
            "explanation": "pd.get_dummies() with drop_first=True drops the first dummy variable after sorting categories alphabetically to prevent multicollinearity (dummy variable trap) in regression models."
        },
        {
            "id": 94,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "Why is it necessary to convert categorical columns to numerical values when using machine learning models?",
            "options": [
                "To increase the textual data in the dataset",
                "To enhance the color scheme of the dataset",
                "To ensure the model can process inputs effectively, as it requires numerical data for calculations",
                "To simplify visual data representation"
            ],
            "correct_answer": 2,
            "explanation": "Machine learning models perform mathematical operations and require numerical inputs. Converting categories to numbers allows models to process and learn from categorical data."
        },
        {
            "id": 95,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What is the purpose of using data.isnull().sum() in a dataset?",
            "options": [
                "To determine the total number of missing values in each column",
                "To sort the data alphabetically",
                "To calculate the sum of all values",
                "To visualize data trends"
            ],
            "correct_answer": 0,
            "explanation": "data.isnull().sum() counts missing values (NaN) in each column, providing a summary of data completeness and identifying columns that need missing value treatment."
        },
        {
            "id": 96,
            "type": "multiple_choice",
            "category": "data_visualization",
            "difficulty": "beginner",
            "question": "What type of variables is the countplot function used for in data visualization?",
            "options": [
                "Categorical variables",
                "Continuous variables",
                "Numerical variables",
                "Both Numerical and Categorical variables"
            ],
            "correct_answer": 0,
            "explanation": "Countplot displays the count of observations in each category, making it ideal for categorical variables with limited distinct groups."
        },
        {
            "id": 97,
            "type": "multiple_choice",
            "category": "linear_regression_basics",
            "difficulty": "beginner",
            "question": "What does the intercept represent in linear regression?",
            "options": [
                "The slope of the regression line",
                "The predicted value of y when x is zero",
                "The correlation between x and y",
                "The error in predictions"
            ],
            "correct_answer": 1,
            "explanation": "The intercept (a in y = a + bx) represents the predicted value of the dependent variable when all independent variables are zero."
        },
        {
            "id": 98,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "What does the R-squared (RÂ²) value indicate in a regression model?",
            "options": [
                "The complexity of the model",
                "The number of predictors used",
                "The percentage of variability in the dependent variable explained by the model",
                "The total cost of the model"
            ],
            "correct_answer": 2,
            "explanation": "R-squared measures the proportion of variance in the dependent variable that is predictable from the independent variables, ranging from 0% to 100%."
        },
        {
            "id": 99,
            "type": "true_false",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "A lesser MAPE (Mean Absolute Percentage Error) indicates a more effective model.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "Lower MAPE values indicate smaller percentage errors between predictions and actual values, meaning better model performance and accuracy."
        },
        {
            "id": 100,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "Which error metric brings units back to the original scale while still punishing large errors?",
            "options": [
                "Mean Absolute Error (MAE)",
                "Mean Squared Error (MSE)",
                "Root Mean Squared Error (RMSE)",
                "Mean Absolute Percentage Error (MAPE)"
            ],
            "correct_answer": 2,
            "explanation": "RMSE is the square root of MSE, returning to the original units of measurement while maintaining sensitivity to larger errors due to the squaring operation."
        },
        {
            "id": 101,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "Why is it important to consider the scale of the target variable when evaluating regression model errors?",
            "options": [
                "Because scale determines if the model is linear or nonlinear",
                "Because it affects the training time",
                "Because the same error can have different impacts depending on context",
                "Because the model might crash on large values"
            ],
            "correct_answer": 2,
            "explanation": "A $50,000 error means something very different when predicting house prices vs. company revenue, so error interpretation depends on the scale and context."
        },
        {
            "id": 102,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "Which metric is most appropriate for understanding prediction errors as a percentage of actual values?",
            "options": [
                "MAE",
                "MSE",
                "RMSE",
                "MAPE"
            ],
            "correct_answer": 3,
            "explanation": "MAPE expresses errors as percentages of actual values, making it scale-independent and easily interpretable across different contexts."
        },
        {
            "id": 103,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "beginner",
            "question": "What is the key difference between loss functions and evaluation metrics?",
            "options": [
                "Loss functions are used during training; evaluation metrics are used after training",
                "Loss functions are only for classification; evaluation metrics are only for regression",
                "Loss functions are more accurate than evaluation metrics",
                "There is no practical difference between them"
            ],
            "correct_answer": 0,
            "explanation": "Loss functions guide model learning during training by measuring individual prediction errors, while evaluation metrics assess overall model performance on unseen data after training."
        },
        {
            "id": 104,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "In a medical test scenario, what does a False Negative represent?",
            "options": [
                "A healthy person incorrectly diagnosed as sick",
                "A sick person incorrectly diagnosed as healthy",
                "A sick person correctly diagnosed as sick",
                "A healthy person correctly diagnosed as healthy"
            ],
            "correct_answer": 1,
            "explanation": "A False Negative occurs when the test fails to detect a true condition - a sick person is told they're healthy, which can have serious consequences."
        },
        {
            "id": 105,
            "type": "multiple_choice",
            "category": "ensemble_learning",
            "difficulty": "intermediate",
            "question": "What is the primary advantage of ensemble methods over single models?",
            "options": [
                "They are always faster to train",
                "They require less data",
                "They reduce the impact of individual model errors through combination",
                "They are simpler to implement"
            ],
            "correct_answer": 2,
            "explanation": "Ensemble methods combine multiple models' predictions, canceling out individual errors and providing more stable, accurate results than any single model."
        },
        {
            "id": 106,
            "type": "multiple_choice",
            "category": "linear_regression_basics",
            "difficulty": "beginner",
            "question": "In the linear regression equation y = a + bx, what does the 'b' coefficient represent?",
            "options": [
                "The predicted value when x is zero",
                "The average error in predictions",
                "The change in y for each one-unit change in x",
                "The correlation between x and y"
            ],
            "correct_answer": 2,
            "explanation": "The 'b' coefficient (slope) represents how much the dependent variable y changes for each one-unit increase in the independent variable x."
        },
        {
            "id": 107,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What is the main purpose of feature scaling in machine learning?",
            "options": [
                "To remove all missing values from the dataset",
                "To ensure all features contribute equally to the model",
                "To convert categorical variables to numerical",
                "To reduce the number of features"
            ],
            "correct_answer": 1,
            "explanation": "Feature scaling ensures that features with different scales contribute equally to model training, preventing features with larger ranges from dominating the learning process."
        },
        {
            "id": 108,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What does a learning curve typically show?",
            "options": [
                "The relationship between features and target variable",
                "Model performance vs. training time",
                "Training and validation performance vs. training set size",
                "Feature importance scores"
            ],
            "correct_answer": 2,
            "explanation": "Learning curves plot training and validation scores against training set size, helping diagnose whether a model suffers from overfitting or underfitting."
        },
        {
            "id": 109,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "When would you prioritize recall over precision in a classification model?",
            "options": [
                "When false positives are more costly than false negatives",
                "When false negatives are more costly than false positives",
                "When both types of errors are equally important",
                "When model interpretability is the main concern"
            ],
            "correct_answer": 1,
            "explanation": "Recall should be prioritized when missing positive cases (false negatives) is more serious than false alarms, such as in medical diagnosis or fraud detection."
        },
        {
            "id": 110,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the primary goal of regularization in machine learning?",
            "options": [
                "To increase model complexity",
                "To reduce overfitting by penalizing large coefficients",
                "To speed up training time",
                "To handle missing values automatically"
            ],
            "correct_answer": 1,
            "explanation": "Regularization techniques like L1 (Lasso) and L2 (Ridge) prevent overfitting by adding penalty terms that shrink model coefficients toward zero."
        },
        {
            "id": 111,
            "type": "multiple_choice",
            "category": "data_quality",
            "difficulty": "beginner",
            "question": "What is the difference between outliers and noise in a dataset?",
            "options": [
                "Outliers are always errors while noise represents true patterns",
                "Outliers are extreme but valid values, while noise is random error",
                "Noise can be removed but outliers must be kept",
                "There is no practical difference between them"
            ],
            "correct_answer": 1,
            "explanation": "Outliers are extreme but potentially valid observations that may represent rare cases, while noise consists of random errors or fluctuations that don't follow meaningful patterns."
        },
        {
            "id": 112,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "Why is it important to use a separate validation set in addition to training and test sets?",
            "options": [
                "To have more data for final evaluation",
                "For hyperparameter tuning without touching the test set",
                "To reduce training time",
                "To ensure all data is used for training"
            ],
            "correct_answer": 1,
            "explanation": "A validation set allows for model selection and hyperparameter tuning while keeping the test set completely untouched for final, unbiased evaluation."
        },
        {
            "id": 113,
            "type": "multiple_choice",
            "category": "regression_basics",
            "difficulty": "beginner",
            "question": "What assumption does linear regression make about the relationship between variables?",
            "options": [
                "The relationship must be perfectly linear",
                "There must be no correlation between variables",
                "All variables must be normally distributed",
                "The relationship can be any complex shape"
            ],
            "correct_answer": 0,
            "explanation": "Linear regression assumes a linear relationship between the independent and dependent variables, meaning changes in x produce proportional changes in y."
        },
        {
            "id": 114,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "What is the main advantage of one-hot encoding over label encoding for categorical variables?",
            "options": [
                "It uses less memory",
                "It preserves the ordinal relationship between categories",
                "It avoids implying artificial ordinal relationships",
                "It works better with tree-based models"
            ],
            "correct_answer": 2,
            "explanation": "One-hot encoding creates binary columns for each category, preventing the model from interpreting arbitrary numerical assignments as having meaningful order or magnitude."
        },
        {
            "id": 115,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the bias-variance tradeoff in machine learning?",
            "options": [
                "The balance between model simplicity and complexity",
                "The tradeoff between training time and accuracy",
                "The choice between different algorithms",
                "The balance between data quantity and quality"
            ],
            "correct_answer": 0,
            "explanation": "The bias-variance tradeoff describes the tension between simple models (high bias, low variance) that may underfit and complex models (low bias, high variance) that may overfit."
        },
        {
            "id": 116,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What does a ROC curve visualize?",
            "options": [
                "The relationship between features and target",
                "The tradeoff between true positive rate and false positive rate",
                "Model performance over training iterations",
                "Feature importance rankings"
            ],
            "correct_answer": 1,
            "explanation": "The ROC curve plots the true positive rate against the false positive rate at different classification thresholds, showing the tradeoff between sensitivity and specificity."
        },
        {
            "id": 117,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What is the purpose of train-test split in machine learning?",
            "options": [
                "To increase the amount of training data",
                "To evaluate model performance on unseen data",
                "To reduce feature dimensionality",
                "To handle class imbalance"
            ],
            "correct_answer": 1,
            "explanation": "Train-test split reserves a portion of data for testing, allowing evaluation of how well the model generalizes to new, unseen data rather than just memorizing training examples."
        },
        {
            "id": 118,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "When comparing regression models, why might you prefer RMSE over MAE?",
            "options": [
                "RMSE is always smaller than MAE",
                "RMSE is more sensitive to large errors",
                "RMSE is easier to interpret",
                "RMSE doesn't require scaled data"
            ],
            "correct_answer": 1,
            "explanation": "RMSE penalizes larger errors more heavily due to the squaring operation, making it more sensitive to outliers and large prediction errors."
        },
        {
            "id": 119,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "What is the F1-score a combination of?",
            "options": [
                "Accuracy and Precision",
                "Precision and Recall",
                "Recall and Specificity",
                "Sensitivity and Specificity"
            ],
            "correct_answer": 1,
            "explanation": "The F1-score is the harmonic mean of precision and recall, providing a single metric that balances both concerns, especially useful for imbalanced datasets."
        },
        {
            "id": 120,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the main difference between parametric and non-parametric models?",
            "options": [
                "Parametric models have fixed numbers of parameters, non-parametric don't",
                "Non-parametric models are always more accurate",
                "Parametric models can only handle numerical data",
                "Non-parametric models are faster to train"
            ],
            "correct_answer": 0,
            "explanation": "Parametric models make assumptions about the data distribution and have a fixed number of parameters, while non-parametric models grow in complexity with the amount of data."
        },
        {
            "id": 121,
            "type": "multiple_choice",
            "category": "linear_regression_basics",
            "difficulty": "beginner",
            "question": "What does multicollinearity refer to in regression analysis?",
            "options": [
                "When the dependent variable has multiple categories",
                "When independent variables are highly correlated with each other",
                "When there are multiple dependent variables",
                "When the regression line has multiple slopes"
            ],
            "correct_answer": 1,
            "explanation": "Multicollinearity occurs when independent variables in a regression model are highly correlated, making it difficult to determine their individual effects on the dependent variable."
        },
        {
            "id": 122,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "What is the main purpose of using Stratified K-Fold cross-validation?",
            "options": [
                "To speed up the cross-validation process",
                "To ensure each fold has the same proportion of class labels as the full dataset",
                "To reduce the number of folds needed",
                "To handle missing values automatically"
            ],
            "correct_answer": 1,
            "explanation": "Stratified K-Fold preserves the percentage of samples for each class in every fold, which is especially important for imbalanced datasets to ensure representative sampling."
        },
        {
            "id": 123,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What does AUC (Area Under the Curve) represent in a ROC curve?",
            "options": [
                "The probability that the model will make a correct prediction",
                "The model's ability to distinguish between classes",
                "The average precision of the model",
                "The training time required for the model"
            ],
            "correct_answer": 1,
            "explanation": "AUC measures the entire two-dimensional area under the ROC curve, representing the model's ability to distinguish between positive and negative classes across all thresholds."
        },
        {
            "id": 124,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the primary goal of dimensionality reduction techniques like PCA?",
            "options": [
                "To increase model complexity",
                "To reduce the number of features while preserving important information",
                "To convert categorical variables to numerical",
                "To handle missing values in the dataset"
            ],
            "correct_answer": 1,
            "explanation": "Dimensionality reduction techniques like PCA transform high-dimensional data into a lower-dimensional space while retaining as much variance/information as possible."
        },
        {
            "id": 125,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "intermediate",
            "question": "When would Adjusted R-squared be preferred over regular R-squared?",
            "options": [
                "When working with classification problems",
                "When comparing models with different numbers of predictors",
                "When the dataset is very small",
                "When all variables are perfectly correlated"
            ],
            "correct_answer": 1,
            "explanation": "Adjusted R-squared penalizes the addition of irrelevant predictors, making it better for comparing models with different numbers of features since regular R-squared always increases with more variables."
        },
        {
            "id": 126,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What is the main difference between standardization and normalization?",
            "options": [
                "Standardization uses min-max scaling, normalization uses z-scores",
                "Standardization uses z-scores, normalization uses min-max scaling",
                "Standardization is for categorical data, normalization for numerical",
                "There is no difference - they are the same"
            ],
            "correct_answer": 1,
            "explanation": "Standardization transforms data to have mean=0 and std=1 (z-scores), while normalization scales data to a fixed range (usually 0-1) using min-max scaling."
        },
        {
            "id": 127,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What is the purpose of a validation curve in machine learning?",
            "options": [
                "To show model performance over training time",
                "To visualize the relationship between model complexity and performance",
                "To display feature importance scores",
                "To show the distribution of prediction errors"
            ],
            "correct_answer": 1,
            "explanation": "Validation curves plot training and validation scores against different values of a hyperparameter, helping to find the optimal model complexity and avoid overfitting/underfitting."
        },
        {
            "id": 128,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "In a confusion matrix, what does specificity measure?",
            "options": [
                "The ability to correctly identify positive cases",
                "The ability to correctly identify negative cases",
                "The overall accuracy of the model",
                "The balance between precision and recall"
            ],
            "correct_answer": 1,
            "explanation": "Specificity (True Negative Rate) measures the proportion of actual negatives that are correctly identified as negative: TN / (TN + FP)."
        },
        {
            "id": 129,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the main characteristic of semi-supervised learning?",
            "options": [
                "It uses only labeled data",
                "It uses only unlabeled data",
                "It uses both labeled and unlabeled data",
                "It doesn't use any data"
            ],
            "correct_answer": 2,
            "explanation": "Semi-supervised learning utilizes a small amount of labeled data along with a large amount of unlabeled data, combining aspects of both supervised and unsupervised learning."
        },
        {
            "id": 130,
            "type": "multiple_choice",
            "category": "data_quality",
            "difficulty": "beginner",
            "question": "What is the difference between missing completely at random (MCAR) and missing at random (MAR)?",
            "options": [
                "MCAR depends on observed data, MAR doesn't",
                "MAR depends on observed data, MCAR doesn't",
                "Both depend on unobserved data",
                "There is no practical difference"
            ],
            "correct_answer": 1,
            "explanation": "MCAR means missingness doesn't depend on any data, while MAR means missingness depends on observed data but not the missing values themselves."
        },
        {
            "id": 131,
            "type": "multiple_choice",
            "category": "regression_basics",
            "difficulty": "intermediate",
            "question": "What is heteroscedasticity in regression analysis?",
            "options": [
                "When the variance of errors is constant across observations",
                "When the variance of errors changes across observations",
                "When errors are normally distributed",
                "When there is a linear relationship between variables"
            ],
            "correct_answer": 1,
            "explanation": "Heteroscedasticity occurs when the variability of the residuals (errors) is not constant across all levels of the independent variables, violating a key assumption of linear regression."
        },
        {
            "id": 132,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What is the purpose of a calibration curve in classification?",
            "options": [
                "To show the relationship between predicted probabilities and actual outcomes",
                "To visualize feature importance",
                "To measure training time efficiency",
                "To display class distribution"
            ],
            "correct_answer": 0,
            "explanation": "Calibration curves compare predicted probabilities with actual observed frequencies, showing how well a model's confidence scores align with real-world probabilities."
        },
        {
            "id": 133,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What is the main advantage of using pipelines in scikit-learn?",
            "options": [
                "To make code run faster",
                "To combine multiple preprocessing steps and model training into a single object",
                "To automatically select the best model",
                "To handle missing values without any code"
            ],
            "correct_answer": 1,
            "explanation": "Pipelines chain together multiple processing steps and the final estimator, ensuring consistent preprocessing during training and prediction while preventing data leakage."
        },
        {
            "id": 134,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "What does the precision-recall curve show that the ROC curve doesn't?",
            "options": [
                "The tradeoff between sensitivity and specificity",
                "Model performance with imbalanced datasets more clearly",
                "The overall accuracy of the model",
                "Feature correlation patterns"
            ],
            "correct_answer": 1,
            "explanation": "Precision-recall curves are more informative than ROC curves for imbalanced datasets because they focus on the performance of the positive (minority) class rather than both classes equally."
        },
        {
            "id": 135,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is transfer learning in machine learning?",
            "options": [
                "Training a model from scratch on new data",
                "Using a pre-trained model as a starting point for a new task",
                "Transferring data between different storage systems",
                "Converting models between different programming languages"
            ],
            "correct_answer": 1,
            "explanation": "Transfer learning involves taking a model trained on one task and reusing it (with fine-tuning) on a different but related task, leveraging learned features to improve performance with less data."
        },
        {
            "id": 136,
            "type": "multiple_choice",
            "category": "model_evaluation",
            "difficulty": "intermediate",
            "question": "What is the purpose of using bootstrapping in machine learning?",
            "options": [
                "To increase training speed",
                "To estimate the sampling distribution of a statistic by resampling with replacement",
                "To reduce model complexity",
                "To handle categorical variables"
            ],
            "correct_answer": 1,
            "explanation": "Bootstrapping creates multiple samples by drawing with replacement from the original data, allowing estimation of statistics' variability and creating ensemble models like Random Forests."
        },
        {
            "id": 137,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "beginner",
            "question": "What is the main risk of using mean imputation for missing values?",
            "options": [
                "It reduces the variance of the variable",
                "It increases the dataset size",
                "It creates too many new features",
                "It only works for categorical variables"
            ],
            "correct_answer": 0,
            "explanation": "Mean imputation reduces the variance of the variable and can distort relationships between variables because it doesn't account for the uncertainty of the missing values."
        },
        {
            "id": 138,
            "type": "multiple_choice",
            "category": "regression_metrics",
            "difficulty": "advanced",
            "question": "What does the Durbin-Watson statistic test for in regression analysis?",
            "options": [
                "Multicollinearity between predictors",
                "Autocorrelation in the residuals",
                "Heteroscedasticity",
                "Normality of residuals"
            ],
            "correct_answer": 1,
            "explanation": "The Durbin-Watson statistic tests for autocorrelation (serial correlation) in the residuals from a regression analysis, which is important for time series data."
        },
        {
            "id": 139,
            "type": "multiple_choice",
            "category": "classification_metrics",
            "difficulty": "intermediate",
            "question": "What is the difference between micro-average and macro-average F1 scores?",
            "options": [
                "Micro-average gives equal weight to each class, macro-average to each instance",
                "Micro-average gives equal weight to each instance, macro-average to each class",
                "They are calculated the same way but on different data splits",
                "There is no practical difference"
            ],
            "correct_answer": 1,
            "explanation": "Micro-averaging aggregates contributions of all classes to compute average metric (instance-based), while macro-averaging computes metric independently for each class and averages (class-based)."
        },
        {
            "id": 140,
            "type": "multiple_choice",
            "category": "machine_learning_fundamentals",
            "difficulty": "beginner",
            "question": "What is the primary purpose of early stopping in neural networks?",
            "options": [
                "To speed up training",
                "To prevent overfitting by stopping when validation performance deteriorates",
                "To ensure all data is used for training",
                "To automatically select the best optimizer"
            ],
            "correct_answer": 1,
            "explanation": "Early stopping monitors validation performance during training and stops when it starts to degrade, preventing the model from overfitting to the training data."
        },
        {
            "id": 141,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "Complete the code to convert a pandas DataFrame to a numpy array using the recommended method:",
            "code_snippet": "numpy_array = df.______()",
            "options": [
                "values",
                "to_numpy",
                "array",
                "convert"
            ],
            "correct_answer": 1,
            "explanation": "to_numpy() is the recommended method in newer pandas versions for converting to numpy array"
        },
        {
            "id": 142,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "Complete the code to convert a pandas Series to numpy array using the legacy method:",
            "code_snippet": "series_array = series.______",
            "options": [
                "to_numpy()",
                "values",
                "array",
                "numpy()"
            ],
            "correct_answer": 1,
            "explanation": ".values is the legacy method for converting pandas Series to numpy array"
        },
        {
            "id": 143,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "What happens to the pandas index when converting a Series to numpy array?",
            "options": [
                "Index is preserved in the array",
                "Index becomes the first column",
                "Index is lost completely",
                "Index is converted to array headers"
            ],
            "correct_answer": 2,
            "explanation": "When converting to numpy array, the pandas index is not preserved"
        },
        {
            "id": 144,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a pandas Series with custom indices:",
            "code_snippet": "series = pd.Series([10, 20, 30], index=['a', 'b', '______'])",
            "options": [
                "'c'",
                "3",
                "index3",
                "third"
            ],
            "correct_answer": 0,
            "explanation": "The index parameter should be a list of labels matching the data length"
        },
        {
            "id": 145,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "Complete the code to add a new column to a DataFrame:",
            "code_snippet": "df['Grade'] = ______",
            "options": [
                "grades",
                "[85, 92, 78]",
                "{'Grade': [85, 92, 78]}",
                "pd.Series([85, 92, 78])"
            ],
            "correct_answer": 1,
            "explanation": "You can assign a list of values directly to create a new column"
        },
        {
            "id": 146,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "When converting a DataFrame with mixed data types to numpy array, what happens?",
            "options": [
                "All data is converted to strings",
                "Data types are preserved separately",
                "Data is upcasted to object type",
                "The conversion fails with an error"
            ],
            "correct_answer": 2,
            "explanation": "Mixed data types in DataFrame are converted to object type in numpy array"
        },
        {
            "id": 147,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select specific columns from a DataFrame:",
            "code_snippet": "selected = df[['Student Name', '______']]",
            "options": [
                "Grade",
                ":Grade",
                "['Grade']",
                "Grade()"
            ],
            "correct_answer": 0,
            "explanation": "Multiple columns are selected using a list of column names: df[['col1', 'col2']]"
        },
        {
            "id": 148,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select rows using loc with a condition:",
            "code_snippet": "high_grades = df.loc[df['Grade'] > 90, ['Student Name', '______']]",
            "options": [
                "Grade",
                ">90",
                "high_grades",
                "df['Grade']"
            ],
            "correct_answer": 0,
            "explanation": "The second parameter of loc specifies which columns to select"
        },
        {
            "id": 149,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "What is the key difference between loc and iloc?",
            "options": [
                "loc uses positions, iloc uses labels",
                "loc uses labels, iloc uses positions",
                "loc is for columns only, iloc for rows only",
                "There is no difference"
            ],
            "correct_answer": 1,
            "explanation": "loc is label-based selection, iloc is position-based selection"
        },
        {
            "id": 150,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "beginner",
            "question": "Complete the code to reshape a 1D numpy array to 3 rows and 4 columns:",
            "code_snippet": "arr_2d = arr_1d.reshape(3, ______)",
            "options": [
                "4",
                "12",
                "-1",
                "0"
            ],
            "correct_answer": 0,
            "explanation": "reshape(3, 4) creates a 2D array with 3 rows and 4 columns"
        },
        {
            "id": 151,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to automatically calculate rows when reshaping:",
            "code_snippet": "auto_shape = arr_1d.reshape(-1, ______)",
            "options": [
                "4",
                "0",
                "None",
                "arr_1d.size"
            ],
            "correct_answer": 0,
            "explanation": "Using -1 for one dimension lets numpy automatically calculate it based on array size"
        },
        {
            "id": 152,
            "type": "multiple_choice",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "What does reshape(-1) do to a multi-dimensional array?",
            "options": [
                "Throws an error",
                "Flattens it to 1D",
                "Reverses the dimensions",
                "Creates a copy with same shape"
            ],
            "correct_answer": 1,
            "explanation": "reshape(-1) flattens any array to 1D regardless of original dimensions"
        },
        {
            "id": 153,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "beginner",
            "question": "Complete the code to update all values in a Series by adding 2.50:",
            "code_snippet": "medicine_prices ______ 2.50",
            "options": [
                "+=",
                "=+",
                "add",
                ".add("
            ],
            "correct_answer": 0,
            "explanation": "The += operator performs in-place addition to all elements in the Series"
        },
        {
            "id": 154,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to filter a Series for values less than 20:",
            "code_snippet": "affordable = medicine_prices[medicine_prices ______ 20]",
            "options": [
                "<",
                ">",
                "==",
                "!="
            ],
            "correct_answer": 0,
            "explanation": "Boolean indexing with < filters for values less than 20"
        },
        {
            "id": 155,
            "type": "multiple_choice",
            "category": "pandas_creation",
            "difficulty": "beginner",
            "question": "Which method is most efficient for creating a Series with custom indices?",
            "options": [
                "Create with default indices then rename",
                "Create with indices from the start",
                "Use rename() method after creation",
                "Convert from dictionary values only"
            ],
            "correct_answer": 1,
            "explanation": "Creating Series with proper indices from the start using the index parameter is most efficient"
        },
        {
            "id": 156,
            "type": "code_completion",
            "category": "pandas_creation",
            "difficulty": "beginner",
            "question": "Complete the code to create a DataFrame from a dictionary:",
            "code_snippet": "df = pd.______({'Name': ['Alice', 'Bob'], 'Age': [25, 30]})",
            "options": [
                "DataFrame",
                "Dataframe",
                "Frame",
                "DF"
            ],
            "correct_answer": 0,
            "explanation": "pd.DataFrame() is used to create a DataFrame from a dictionary where keys become column names"
        },
        {
            "id": 157,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "What is the main advantage of using .to_numpy() over .values?",
            "options": [
                "It's faster for large datasets",
                "It preserves the index in the array",
                "It's the recommended method in newer pandas versions",
                "It works with older pandas versions"
            ],
            "correct_answer": 2,
            "explanation": ".to_numpy() is the recommended method in pandas 0.24+ and provides more consistency"
        },
        {
            "id": 158,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select columns using iloc by position:",
            "code_snippet": "selected = df.iloc[:, [0, 2, ______]]",
            "options": [
                "4",
                "'Grade'",
                "Grade",
                "-1"
            ],
            "correct_answer": 0,
            "explanation": "iloc uses integer positions, so [0, 2, 4] selects the 1st, 3rd and 5th columns"
        },
        {
            "id": 159,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to calculate the average grade in a DataFrame:",
            "code_snippet": "average_grade = df['Grade'].______()",
            "options": [
                "mean",
                "average",
                "avg",
                "median"
            ],
            "correct_answer": 0,
            "explanation": ".mean() calculates the arithmetic mean of the values in the Series"
        },
        {
            "id": 160,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "What is the difference between loc[1:3] and iloc[1:3] for row selection?",
            "options": [
                "loc includes row 3, iloc excludes row 3",
                "loc excludes row 3, iloc includes row 3",
                "Both include row 3",
                "Both exclude row 3"
            ],
            "correct_answer": 0,
            "explanation": "loc is inclusive of the end label, while iloc is exclusive of the end position"
        },
        {
            "id": 161,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "beginner",
            "question": "Complete the code to create a numpy array from a list:",
            "code_snippet": "arr = np.______([1, 2, 3, 4, 5])",
            "options": [
                "array",
                "Array",
                "arr",
                "np_array"
            ],
            "correct_answer": 0,
            "explanation": "np.array() is used to create a numpy array from a list or other sequence"
        },
        {
            "id": 162,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to find the maximum value in a Series:",
            "code_snippet": "max_price = medicine_prices.______()",
            "options": [
                "max",
                "maximum",
                "highest",
                "peak"
            ],
            "correct_answer": 0,
            "explanation": ".max() returns the maximum value in the Series"
        },
        {
            "id": 163,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "When converting a DataFrame to numpy array, what is preserved from the original DataFrame?",
            "options": [
                "Column names and index",
                "Only the data values",
                "Column names but not index",
                "Index but not column names"
            ],
            "correct_answer": 1,
            "explanation": "Only the data values are preserved; both column names and index are lost in the numpy array"
        },
        {
            "id": 164,
            "type": "code_completion",
            "category": "pandas_creation",
            "difficulty": "intermediate",
            "question": "Complete the code to create a Series from a dictionary:",
            "code_snippet": "series = pd.______({'A': 1, 'B': 2, 'C': 3})",
            "options": [
                "Series",
                "series",
                "Ser",
                "DictSeries"
            ],
            "correct_answer": 0,
            "explanation": "pd.Series() can be created from a dictionary where keys become the index"
        },
        {
            "id": 165,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows where Age is between 25 and 30:",
            "code_snippet": "selected = df.loc[df['Age'].______(25, 30)]",
            "options": [
                "between",
                "range",
                "in_range",
                "from_to"
            ],
            "correct_answer": 0,
            "explanation": ".between() method selects values within the specified inclusive range"
        },
        {
            "id": 166,
            "type": "multiple_choice",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "What happens if you try to reshape an array with incompatible dimensions?",
            "options": [
                "It automatically pads with zeros",
                "It throws a ValueError",
                "It truncates the extra elements",
                "It repeats the array elements"
            ],
            "correct_answer": 1,
            "explanation": "Reshaping requires the product of dimensions to match the total elements, otherwise ValueError is raised"
        },
        {
            "id": 167,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to sort a DataFrame by a column in descending order:",
            "code_snippet": "df_sorted = df.sort_values('Grade', ______=False)",
            "options": [
                "ascending",
                "order",
                "direction",
                "sort_order"
            ],
            "correct_answer": 0,
            "explanation": "ascending=False parameter sorts values in descending order"
        },
        {
            "id": 168,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "Complete the code to convert only specific columns to numpy array:",
            "code_snippet": "selected_array = df[['X', 'Y']].______()",
            "options": [
                "to_numpy",
                "values",
                "numpy",
                "array"
            ],
            "correct_answer": 0,
            "explanation": "First select columns using df[['X', 'Y']], then convert to numpy array with .to_numpy()"
        },
        {
            "id": 169,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "What is the data type of a pandas Series containing mixed numeric and string values?",
            "options": [
                "object",
                "mixed",
                "string",
                "variant"
            ],
            "correct_answer": 0,
            "explanation": "Pandas uses 'object' dtype for Series containing mixed types or strings"
        },
        {
            "id": 170,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to get the shape of a numpy array:",
            "code_snippet": "array_shape = arr.______",
            "options": [
                "shape",
                "size",
                "dim",
                "dimensions"
            ],
            "correct_answer": 0,
            "explanation": ".shape attribute returns a tuple representing the dimensions of the array"
        },
        {
            "id": 171,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "advanced",
            "question": "Complete the code to apply a custom function to each element in a Series:",
            "code_snippet": "result = series.______(lambda x: x * 2)",
            "options": [
                "apply",
                "map",
                "transform",
                "function"
            ],
            "correct_answer": 0,
            "explanation": ".apply() method applies a function to each element in the Series"
        },
        {
            "id": 172,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Which method allows selection using boolean conditions?",
            "options": [
                "Only loc",
                "Only iloc",
                "Both loc and iloc",
                "Neither loc nor iloc"
            ],
            "correct_answer": 0,
            "explanation": "loc supports boolean array indexing, while iloc is primarily for integer position-based selection"
        },
        {
            "id": 173,
            "type": "code_completion",
            "category": "pandas_creation",
            "difficulty": "beginner",
            "question": "Complete the code to create a single-column DataFrame:",
            "code_snippet": "df = pd.DataFrame(students, columns=['______'])",
            "options": [
                "Student Name",
                "student_name",
                "Students",
                "Name"
            ],
            "correct_answer": 0,
            "explanation": "The columns parameter specifies the column name for the single column DataFrame"
        },
        {
            "id": 174,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "beginner",
            "question": "Complete the code to create a sequence of numbers with arange:",
            "code_snippet": "arr = np.______(0, 10, 2)",
            "options": [
                "arange",
                "range",
                "sequence",
                "linspace"
            ],
            "correct_answer": 0,
            "explanation": "np.arange(start, stop, step) creates evenly spaced values within an interval"
        },
        {
            "id": 175,
            "type": "multiple_choice",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "What is the result of performing a mathematical operation on a pandas Series?",
            "options": [
                "A new Series with the operation applied to each element",
                "The original Series is modified in place",
                "A single scalar value",
                "A DataFrame with the results"
            ],
            "correct_answer": 0,
            "explanation": "Mathematical operations on Series are vectorized and return a new Series with the same index"
        },
        {
            "id": 176,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to find the index of the maximum value in a Series:",
            "code_snippet": "max_index = medicine_prices.______()",
            "options": [
                "idxmax",
                "argmax",
                "max_index",
                "find_max"
            ],
            "correct_answer": 0,
            "explanation": ".idxmax() returns the index label of the maximum value in the Series"
        },
        {
            "id": 177,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "What is the relationship between pandas Series and numpy arrays internally?",
            "options": [
                "Series are built on top of numpy arrays",
                "They are completely independent",
                "Numpy arrays are built on pandas Series",
                "They share no common foundation"
            ],
            "correct_answer": 0,
            "explanation": "Pandas Series are built on top of numpy arrays internally, making conversion very efficient"
        },
        {
            "id": 178,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows where Department is either 'HR' or 'Finance':",
            "code_snippet": "selected = df.loc[df['Department'].______(['HR', 'Finance'])]",
            "options": [
                "isin",
                "in",
                "contains",
                "matches"
            ],
            "correct_answer": 0,
            "explanation": ".isin() method checks if each element is contained in the provided list of values"
        },
        {
            "id": 179,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to get the number of dimensions of a numpy array:",
            "code_snippet": "dims = arr.______",
            "options": [
                "ndim",
                "dims",
                "dimensions",
                "rank"
            ],
            "correct_answer": 0,
            "explanation": ".ndim attribute returns the number of array dimensions"
        },
        {
            "id": 180,
            "type": "multiple_choice",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "When using += to modify a Series, what happens to the original data?",
            "options": [
                "Original Series is modified in place",
                "A new Series is created",
                "Operation fails with error",
                "Only a view is modified"
            ],
            "correct_answer": 0,
            "explanation": "The += operator performs in-place modification of the original Series"
        },
        {
            "id": 181,
            "type": "code_completion",
            "category": "pandas_creation",
            "difficulty": "beginner",
            "question": "Complete the code to rename the index of a Series:",
            "code_snippet": "series.index = ['A', 'B', '______']",
            "options": [
                "'C'",
                "2",
                "third",
                "index_2"
            ],
            "correct_answer": 0,
            "explanation": "You can assign a new list of labels directly to the .index attribute"
        },
        {
            "id": 182,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to count the number of A grades in a Series:",
            "code_snippet": "count_a = (df['Letter Grade'] == 'A').______()",
            "options": [
                "sum",
                "count",
                "total",
                "size"
            ],
            "correct_answer": 0,
            "explanation": "Boolean Series can be summed to count True values (True=1, False=0)"
        },
        {
            "id": 183,
            "type": "multiple_choice",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "What is the difference between reshape and resize in numpy?",
            "options": [
                "reshape returns new array, resize can modify original",
                "resize returns new array, reshape modifies original",
                "They are identical",
                "reshape works only with 2D arrays"
            ],
            "correct_answer": 0,
            "explanation": "reshape returns a new array with new shape, while resize can modify the original array or repeat elements"
        },
        {
            "id": 184,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select numeric columns only from a DataFrame:",
            "code_snippet": "numeric_cols = df.______(include=['int64', 'float64'])",
            "options": [
                "select_dtypes",
                "dtype_select",
                "filter_dtypes",
                "numeric_only"
            ],
            "correct_answer": 0,
            "explanation": "select_dtypes() method selects columns based on their data types"
        },
        {
            "id": 185,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "beginner",
            "question": "Complete the code to get the data type of a Series:",
            "code_snippet": "dtype_info = series.______",
            "options": [
                "dtype",
                "dtypes",
                "type",
                "data_type"
            ],
            "correct_answer": 0,
            "explanation": ".dtype attribute returns the data type of the Series elements"
        },
        {
            "id": 186,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "Which method should you use for converting to numpy array in pandas 0.24+?",
            "options": [
                ".values for all cases",
                ".to_numpy() for all cases",
                ".array for new code",
                ".numpy() for compatibility"
            ],
            "correct_answer": 1,
            "explanation": ".to_numpy() is the recommended method in pandas 0.24 and later versions"
        },
        {
            "id": 187,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to flatten a multi-dimensional array to 1D:",
            "code_snippet": "flat_arr = arr_2d.______()",
            "options": [
                "flatten",
                "ravel",
                "reshape(-1)",
                "All of the above"
            ],
            "correct_answer": 3,
            "explanation": "All three methods can flatten an array to 1D, with slight differences in memory behavior"
        },
        {
            "id": 188,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to update values conditionally using a boolean mask:",
            "code_snippet": "df.loc[df['Grade'] < 70, 'Grade Status'] = '______'",
            "options": [
                "'F'",
                "Fail",
                "Failed",
                "Failing"
            ],
            "correct_answer": 0,
            "explanation": "loc with boolean mask allows conditional assignment to specific cells"
        },
        {
            "id": 189,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "What does df.filter(regex='Name') select?",
            "options": [
                "Columns containing 'Name' in their names",
                "Rows containing 'Name' in their index",
                "Cells containing 'Name'",
                "Only the 'Name' column exactly"
            ],
            "correct_answer": 0,
            "explanation": "filter with regex parameter selects columns whose names match the regular expression pattern"
        },
        {
            "id": 190,
            "type": "code_completion",
            "category": "pandas_creation",
            "difficulty": "beginner",
            "question": "Complete the code to set a custom index name for a DataFrame:",
            "code_snippet": "df.index.name = '______'",
            "options": [
                "'Student ID'",
                "Student_ID",
                "index_name",
                "Student ID"
            ],
            "correct_answer": 0,
            "explanation": "The index.name attribute can be set to a string to name the index"
        },
        {
            "id": 191,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "advanced",
            "question": "Complete the code to reshape with column-major (Fortran) order:",
            "code_snippet": "f_style = arr.reshape(3, 4, order='______')",
            "options": [
                "'F'",
                "'C'",
                "'A'",
                "'F-style'"
            ],
            "correct_answer": 0,
            "explanation": "order='F' specifies Fortran-style (column-major) memory order for reshaping"
        },
        {
            "id": 192,
            "type": "multiple_choice",
            "category": "pandas_operations",
            "difficulty": "beginner",
            "question": "What is the result of accessing a specific value using series['index_label']?",
            "options": [
                "The value at that index position",
                "A new Series with one element",
                "The scalar value at that index label",
                "A DataFrame with one row"
            ],
            "correct_answer": 2,
            "explanation": "Indexing a Series with a single label returns the scalar value at that position"
        },
        {
            "id": 193,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to calculate the total sum of a Series:",
            "code_snippet": "total = medicine_prices.______()",
            "options": [
                "sum",
                "total",
                "add",
                "aggregate"
            ],
            "correct_answer": 0,
            "explanation": ".sum() method returns the sum of all values in the Series"
        },
        {
            "id": 194,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select every other row using iloc:",
            "code_snippet": "every_other = df.iloc[______]",
            "options": [
                "::2",
                "[::2]",
                "1::2",
                "range(0,len(df),2)"
            ],
            "correct_answer": 0,
            "explanation": "iloc[::2] uses slicing with step 2 to select every other row"
        },
        {
            "id": 195,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "When converting a DataFrame with datetime columns to numpy array, what happens?",
            "options": [
                "Datetimes convert to Unix timestamps",
                "Datetimes remain as datetime objects",
                "Conversion fails with error",
                "Datetimes convert to strings"
            ],
            "correct_answer": 1,
            "explanation": "Datetime objects in pandas are preserved as datetime64 objects in numpy arrays"
        },
        {
            "id": 196,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "advanced",
            "question": "Complete the code to create a new column based on conditional logic:",
            "code_snippet": "df['Status'] = np.______(df['Grade'] >= 90, 'Excellent', 'Good')",
            "options": [
                "where",
                "select",
                "choose",
                "ifelse"
            ],
            "correct_answer": 0,
            "explanation": "np.where(condition, value_if_true, value_if_false) performs element-wise conditional assignment"
        },
        {
            "id": 197,
            "type": "multiple_choice",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "What is the key requirement for successful array reshaping?",
            "options": [
                "All elements must be the same type",
                "The product of new dimensions must equal total elements",
                "Array must be 1D initially",
                "New dimensions must be smaller than original"
            ],
            "correct_answer": 1,
            "explanation": "The product of the new shape dimensions must exactly match the total number of elements in the array"
        },
        {
            "id": 198,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select the last 3 rows of a DataFrame:",
            "code_snippet": "last_three = df.iloc[______]",
            "options": [
                "-3:",
                "[-3:]",
                "[-3,-2,-1]",
                "len(df)-3:"
            ],
            "correct_answer": 0,
            "explanation": "Negative indexing with slicing: -3: selects from the third last element to the end"
        },
        {
            "id": 199,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to calculate percentage increase between two Series:",
            "code_snippet": "pct_increase = (new_prices - old_prices) / old_prices * ______",
            "options": [
                "100",
                "1",
                "100.0",
                "100%"
            ],
            "correct_answer": 0,
            "explanation": "Multiplying by 100 converts the decimal ratio to percentage"
        },
        {
            "id": 200,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "What is the dtype of a numpy array created from a Series with mixed integers and floats?",
            "options": [
                "float64",
                "object",
                "int64",
                "mixed"
            ],
            "correct_answer": 0,
            "explanation": "When mixing integers and floats, numpy upcasts to float64 to preserve decimal precision"
        },
        {
            "id": 201,
            "type": "code_completion",
            "category": "pandas_creation",
            "difficulty": "advanced",
            "question": "Complete the code to create a DataFrame with a custom index from a dictionary:",
            "code_snippet": "df = pd.DataFrame(data, index=['A', 'B', '______'])",
            "options": [
                "'C'",
                "2",
                "row3",
                "index_2"
            ],
            "correct_answer": 0,
            "explanation": "The index parameter can be provided when creating DataFrame to set custom row labels"
        },
        {
            "id": 202,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "advanced",
            "question": "Complete the code to create a 3D array representing RGB image data:",
            "code_snippet": "image_3d = pixel_data.reshape(3, 3, ______)",
            "options": [
                "3",
                "4",
                "9",
                "1"
            ],
            "correct_answer": 0,
            "explanation": "A 3x3 RGB image has shape (3, 3, 3) for 3 color channels"
        },
        {
            "id": 203,
            "type": "multiple_choice",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "What is the result of applying a lambda function with apply() on a Series?",
            "options": [
                "A new Series with transformed values",
                "The original Series is modified",
                "A single aggregated value",
                "A DataFrame with results"
            ],
            "correct_answer": 0,
            "explanation": "apply() with lambda function returns a new Series with the function applied to each element"
        },
        {
            "id": 204,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows where Salary is greater than 60000 and Department is 'IT':",
            "code_snippet": "selected = df.loc[(df['Salary'] > 60000) ______ (df['Department'] == 'IT')]",
            "options": [
                "&",
                "and",
                "&&",
                "|"
            ],
            "correct_answer": 0,
            "explanation": "Use & for element-wise logical AND (not 'and' which is for scalar boolean operations)"
        },
        {
            "id": 205,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "beginner",
            "question": "Complete the code to get basic descriptive statistics of a DataFrame:",
            "code_snippet": "stats = df.______()",
            "options": [
                "describe",
                "info",
                "stats",
                "summary"
            ],
            "correct_answer": 0,
            "explanation": "describe() provides count, mean, std, min, max, and quartiles for numerical columns"
        },
        {
            "id": 206,
            "type": "multiple_choice",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "What is the advantage of using -1 in reshape operations?",
            "options": [
                "Automatically calculates that dimension",
                "Reverses the array order",
                "Creates a 1D array",
                "Handles missing values"
            ],
            "correct_answer": 0,
            "explanation": "Using -1 for one dimension lets numpy automatically calculate it based on array size and other dimensions"
        },
        {
            "id": 207,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "advanced",
            "question": "Complete the code to update values using both row and column selection with loc:",
            "code_snippet": "df.loc[df['Age'] < 25, '______'] = 'Junior'",
            "options": [
                "Category",
                "'Category'",
                "['Category']",
                "df['Category']"
            ],
            "correct_answer": 0,
            "explanation": "loc allows selecting rows by condition and columns by name for assignment"
        },
        {
            "id": 208,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "Complete the code to verify two arrays contain equal values:",
            "code_snippet": "are_equal = np.______(series.values, numpy_array)",
            "options": [
                "array_equal",
                "equal",
                "compare",
                "arrays_equal"
            ],
            "correct_answer": 0,
            "explanation": "np.array_equal() returns True if two arrays have the same shape and elements"
        },
        {
            "id": 209,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "What does df.iloc[1:6:2, :3] select?",
            "options": [
                "Rows 1,3,5 and first 3 columns",
                "Rows 1 through 6 and columns 0-3",
                "Every 2nd row from 1-6 and all columns",
                "Rows 1,3,5 and columns 1-3"
            ],
            "correct_answer": 0,
            "explanation": "iloc[1:6:2] selects rows 1,3,5 (start:stop:step) and :3 selects first 3 columns"
        },
        {
            "id": 210,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to find the most frequent value in a Series:",
            "code_snippet": "mode_value = series.______()",
            "options": [
                "mode",
                "most_frequent",
                "freq",
                "common"
            ],
            "correct_answer": 0,
            "explanation": "mode() returns the most frequently occurring value in the Series"
        },
        {
            "id": 211,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "beginner",
            "question": "Complete the code to get the total number of elements in an array:",
            "code_snippet": "total_elements = arr.______",
            "options": [
                "size",
                "count",
                "len",
                "elements"
            ],
            "correct_answer": 0,
            "explanation": ".size attribute returns the total number of elements in the array"
        },
        {
            "id": 212,
            "type": "multiple_choice",
            "category": "pandas_creation",
            "difficulty": "intermediate",
            "question": "Which method is most readable for creating a Series with meaningful indices?",
            "options": [
                "From dictionary with keys as indices",
                "Create then rename indices",
                "Using rename() method",
                "All are equally readable"
            ],
            "correct_answer": 0,
            "explanation": "Creating from dictionary makes the relationship between values and indices immediately clear"
        },
        {
            "id": 213,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "advanced",
            "question": "Complete the code to calculate cumulative sum of a Series:",
            "code_snippet": "cumulative = series.______()",
            "options": [
                "cumsum",
                "cumulative_sum",
                "running_total",
                "accumulate"
            ],
            "correct_answer": 0,
            "explanation": "cumsum() returns the cumulative sum of elements in the Series"
        },
        {
            "id": 214,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select columns by data type:",
            "code_snippet": "numeric_data = df.______(include=['number'])",
            "options": [
                "select_dtypes",
                "filter_types",
                "dtype_select",
                "numeric_columns"
            ],
            "correct_answer": 0,
            "explanation": "select_dtypes() with include=['number'] selects all numeric columns (int and float)"
        },
        {
            "id": 215,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "advanced",
            "question": "What is the main performance benefit of pandas-to-numpy conversion?",
            "options": [
                "No data copying occurs",
                "Automatic parallel processing",
                "Built on same memory foundation",
                "Compressed storage format"
            ],
            "correct_answer": 2,
            "explanation": "Pandas is built on numpy arrays internally, so conversion is very efficient with minimal overhead"
        },
        {
            "id": 216,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "beginner",
            "question": "Complete the code to reset the index of a DataFrame:",
            "code_snippet": "df_reset = df.______()",
            "options": [
                "reset_index",
                "reindex",
                "new_index",
                "default_index"
            ],
            "correct_answer": 0,
            "explanation": "reset_index() converts the index to a regular column and creates a new default integer index"
        },
        {
            "id": 217,
            "type": "code_completion",
            "category": "numpy_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to create an array of random integers:",
            "code_snippet": "random_arr = np.random.______(0, 100, 10)",
            "options": [
                "randint",
                "random_int",
                "integers",
                "rand"
            ],
            "correct_answer": 0,
            "explanation": "np.random.randint(low, high, size) generates random integers in the specified range"
        },
        {
            "id": 218,
            "type": "multiple_choice",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "What is vectorized operation in pandas?",
            "options": [
                "Operations applied to entire arrays without loops",
                "Operations using vector graphics",
                "Linear algebra operations only",
                "Operations on geometric vectors"
            ],
            "correct_answer": 0,
            "explanation": "Vectorized operations apply to entire arrays/series at once, leveraging numpy's efficient C implementation"
        },
        {
            "id": 219,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows using multiple conditions with OR logic:",
            "code_snippet": "selected = df.loc[(df['Age'] < 25) ______ (df['Grade'] > 90)]",
            "options": [
                "|",
                "or",
                "||",
                "&"
            ],
            "correct_answer": 0,
            "explanation": "Use | for element-wise logical OR (not 'or' which is for scalar boolean operations)"
        },
        {
            "id": 220,
            "type": "code_completion",
            "category": "pandas_operations",
            "difficulty": "intermediate",
            "question": "Complete the code to drop rows with missing values:",
            "code_snippet": "df_clean = df.______()",
            "options": [
                "dropna",
                "remove_na",
                "clean",
                "fillna"
            ],
            "correct_answer": 0,
            "explanation": "dropna() removes rows containing any missing/NaN values from the DataFrame"
        },
        {
            "id": 221,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create an empty DataFrame:",
            "code_snippet": "df = pd.______()",
            "options": [
                "DataFrame",
                "Dataframe",
                "EmptyDataFrame",
                "Frame"
            ],
            "correct_answer": 0,
            "explanation": "pd.DataFrame() with no arguments creates an empty DataFrame"
        },
        {
            "id": 222,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "What is the default index type when creating a new DataFrame?",
            "options": [
                "RangeIndex starting from 0",
                "String indices",
                "No index",
                "Random numbers"
            ],
            "correct_answer": 0,
            "explanation": "Pandas creates a RangeIndex (0, 1, 2, ...) by default for new DataFrames"
        },
        {
            "id": 223,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a Series from a single value repeated:",
            "code_snippet": "series = pd.Series(5, index=______(5))",
            "options": [
                "range",
                "list",
                "np.arange",
                "generate"
            ],
            "correct_answer": 0,
            "explanation": "range(5) creates indices [0,1,2,3,4] for a Series with value 5 repeated"
        },
        {
            "id": 224,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "intermediate",
            "question": "What happens if you create a Series from a dictionary with duplicate keys?",
            "options": [
                "Later values overwrite earlier ones",
                "Error is raised",
                "Creates multi-index Series",
                "Keeps both values in a list"
            ],
            "correct_answer": 0,
            "explanation": "Dictionary keys must be unique, so later values overwrite earlier ones when creating Series"
        },
        {
            "id": 225,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to set a column as the DataFrame index:",
            "code_snippet": "df_indexed = df.______('Student_ID')",
            "options": [
                "set_index",
                "index_set",
                "make_index",
                "set_index_col"
            ],
            "correct_answer": 0,
            "explanation": "set_index() method sets a column as the new index of the DataFrame"
        },
        {
            "id": 226,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "Which method shows the first 5 rows of a DataFrame by default?",
            "options": [
                "head()",
                "first()",
                "show()",
                "display()"
            ],
            "correct_answer": 0,
            "explanation": "head() displays the first 5 rows, or specify number like head(10) for first 10 rows"
        },
        {
            "id": 227,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to get DataFrame column names as a list:",
            "code_snippet": "columns_list = df.______.tolist()",
            "options": [
                "columns",
                "cols",
                "column_names",
                "names"
            ],
            "correct_answer": 0,
            "explanation": "df.columns returns an Index object that can be converted to list with tolist()"
        },
        {
            "id": 228,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "What is the data type of df.shape output?",
            "options": [
                "Tuple",
                "List",
                "DataFrame",
                "Integer"
            ],
            "correct_answer": 0,
            "explanation": "df.shape returns a tuple (rows, columns) representing the dimensions"
        },
        {
            "id": 229,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "advanced",
            "question": "Complete the code to create a DataFrame with datetime index:",
            "code_snippet": "dates = pd.date_range('2023-01-01', ______=5)",
            "options": [
                "periods",
                "days",
                "length",
                "size"
            ],
            "correct_answer": 0,
            "explanation": "periods parameter specifies the number of periods to generate"
        },
        {
            "id": 230,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "intermediate",
            "question": "What method provides memory usage and data type information?",
            "options": [
                "info()",
                "describe()",
                "memory()",
                "dtypes()"
            ],
            "correct_answer": 0,
            "explanation": "info() shows column data types, non-null counts, and memory usage"
        },
        {
            "id": 231,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "Complete the code to get the number of rows and columns:",
            "code_snippet": "rows, cols = df.______",
            "options": [
                "shape",
                "size",
                "dim",
                "dimensions"
            ],
            "correct_answer": 0,
            "explanation": "df.shape returns (rows, columns) which can be unpacked into variables"
        },
        {
            "id": 232,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "intermediate",
            "question": "When creating DataFrame from dictionary, what determines column order?",
            "options": [
                "Insertion order (Python 3.6+)",
                "Alphabetical order",
                "Random order",
                "Based on values"
            ],
            "correct_answer": 0,
            "explanation": "In Python 3.6+, dictionaries maintain insertion order, which determines DataFrame column order"
        },
        {
            "id": 233,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "advanced",
            "question": "Complete the code to create a multi-index DataFrame:",
            "code_snippet": "df_multi = pd.DataFrame(data, index=pd.______([['A','A','B','B'], [1,2,1,2]]))",
            "options": [
                "MultiIndex",
                "MultiIndex.from_tuples",
                "MultiIndex.from_arrays",
                "MultiIndex.from_product"
            ],
            "correct_answer": 2,
            "explanation": "MultiIndex.from_arrays() creates a multi-index from lists of arrays"
        },
        {
            "id": 234,
            "type": "multiple_choice",
            "category": "pandas_basics",
            "difficulty": "beginner",
            "question": "What is the output of len(df) for a DataFrame?",
            "options": [
                "Number of rows",
                "Number of columns",
                "Total elements",
                "Memory size"
            ],
            "correct_answer": 0,
            "explanation": "len(df) returns the number of rows in the DataFrame"
        },
        {
            "id": 235,
            "type": "code_completion",
            "category": "pandas_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to rename DataFrame columns:",
            "code_snippet": "df_renamed = df.______(columns={'old_name': 'new_name'})",
            "options": [
                "rename",
                "rename_columns",
                "columns_rename",
                "set_columns"
            ],
            "correct_answer": 0,
            "explanation": "rename() method with columns parameter dictionary maps old names to new names"
        },
        {
            "id": 236,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "beginner",
            "question": "Complete the code to select a single column as Series:",
            "code_snippet": "name_series = df['______']",
            "options": [
                "Student Name",
                "Student_Name",
                "student name",
                "StudentName"
            ],
            "correct_answer": 0,
            "explanation": "Column names with spaces must be quoted when using bracket notation"
        },
        {
            "id": 237,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "beginner",
            "question": "What is the difference between df['col'] and df[['col']]?",
            "options": [
                "First returns Series, second returns DataFrame",
                "First returns DataFrame, second returns Series",
                "Both return Series",
                "Both return DataFrame"
            ],
            "correct_answer": 0,
            "explanation": "Single bracket returns Series, double brackets returns single-column DataFrame"
        },
        {
            "id": 238,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select rows by label range:",
            "code_snippet": "selected = df.______['A':'C']",
            "options": [
                "loc",
                "iloc",
                "ix",
                "at"
            ],
            "correct_answer": 0,
            "explanation": "loc supports label-based slicing including string ranges"
        },
        {
            "id": 239,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "What does df.at[5, 'Column'] access?",
            "options": [
                "Single value by label",
                "Single value by position",
                "Row by label",
                "Column by name"
            ],
            "correct_answer": 0,
            "explanation": "at[] accesses single value for row/column label pair (fast for scalars)"
        },
        {
            "id": 240,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows where column contains substring:",
            "code_snippet": "selected = df[df['Major'].______('Bio')]",
            "options": [
                "str.contains",
                "contains",
                "has",
                "includes"
            ],
            "correct_answer": 0,
            "explanation": "str.contains() checks if string contains substring, returns boolean Series"
        },
        {
            "id": 241,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Which method is fastest for accessing a single scalar value?",
            "options": [
                "at[]",
                "loc[]",
                "iloc[]",
                "Direct indexing"
            ],
            "correct_answer": 0,
            "explanation": "at[] is optimized for fast scalar value access compared to loc[]/iloc[]"
        },
        {
            "id": 242,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows with missing values in a column:",
            "code_snippet": "missing = df[df['Grade'].______()]",
            "options": [
                "isna",
                "isnull",
                "isna() or isnull()",
                "missing"
            ],
            "correct_answer": 2,
            "explanation": "Both isna() and isnull() return boolean Series indicating missing values"
        },
        {
            "id": 243,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "beginner",
            "question": "What does df.iloc[0] return?",
            "options": [
                "First row as Series",
                "First column as Series",
                "First element",
                "First row as DataFrame"
            ],
            "correct_answer": 0,
            "explanation": "iloc[0] selects the first row by position and returns it as a Series"
        },
        {
            "id": 244,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select every nth row:",
            "code_snippet": "every_third = df.iloc[______]",
            "options": [
                "::3",
                "[::3]",
                "1::3",
                "range(0,len(df),3)"
            ],
            "correct_answer": 0,
            "explanation": "iloc[::3] uses slicing with step 3 to select every third row"
        },
        {
            "id": 245,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "What is the purpose of the query() method?",
            "options": [
                "SQL-like querying with string expressions",
                "Fast numerical computations",
                "Database connections",
                "Web API queries"
            ],
            "correct_answer": 0,
            "explanation": "query() allows SQL-like filtering using string expressions: df.query('Age > 25')"
        },
        {
            "id": 246,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select columns matching pattern:",
            "code_snippet": "name_cols = df.______(like='Name')",
            "options": [
                "filter",
                "select",
                "loc",
                "regex_filter"
            ],
            "correct_answer": 0,
            "explanation": "filter(like='pattern') selects columns whose names contain the substring"
        },
        {
            "id": 247,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "beginner",
            "question": "How to select the last row of a DataFrame?",
            "options": [
                "df.iloc[-1]",
                "df.loc[-1]",
                "df.last()",
                "df.end()"
            ],
            "correct_answer": 0,
            "explanation": "iloc[-1] selects the last row by position (negative indexing)"
        },
        {
            "id": 248,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "advanced",
            "question": "Complete the code to select rows where values are in a list:",
            "code_snippet": "majors = df[df['Major'].______(['Math', 'Physics'])]",
            "options": [
                "isin",
                "in",
                "contains",
                "matches"
            ],
            "correct_answer": 0,
            "explanation": "isin() checks if each element is contained in the provided list"
        },
        {
            "id": 249,
            "type": "multiple_choice",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "What does df.iat[2, 3] access?",
            "options": [
                "Value at row 2, column 3 by position",
                "Value at row 2, column 3 by label",
                "Row 2 and column 3",
                "Columns 2 through 3"
            ],
            "correct_answer": 0,
            "explanation": "iat[] accesses single value by integer position (fast scalar access)"
        },
        {
            "id": 250,
            "type": "code_completion",
            "category": "pandas_selection",
            "difficulty": "intermediate",
            "question": "Complete the code to select first 3 rows and last 2 columns:",
            "code_snippet": "subset = df.iloc[______, -2:]",
            "options": [
                ":3",
                "0:3",
                "[0,1,2]",
                "range(3)"
            ],
            "correct_answer": 0,
            "explanation": "iloc[:3, -2:] selects first 3 rows and last 2 columns using slicing"
        },
        {
            "id": 251,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "Complete the code to check if conversion preserved data equality:",
            "code_snippet": "equal = np.______(df.values, df.to_numpy())",
            "options": [
                "array_equal",
                "equal",
                "allclose",
                "compare"
            ],
            "correct_answer": 0,
            "explanation": "np.array_equal() checks if two arrays have identical shapes and elements"
        },
        {
            "id": 252,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "What is the main advantage of .to_numpy() over .values?",
            "options": [
                "More consistent behavior and options",
                "Faster execution",
                "Smaller memory footprint",
                "Preserves column names"
            ],
            "correct_answer": 0,
            "explanation": "to_numpy() provides more consistent behavior and options like dtype control"
        },
        {
            "id": 253,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "advanced",
            "question": "Complete the code to convert with specific data type:",
            "code_snippet": "float_array = df.to_numpy(______='float64')",
            "options": [
                "dtype",
                "type",
                "dtype_",
                "astype"
            ],
            "correct_answer": 0,
            "explanation": "dtype parameter forces specific data type during conversion"
        },
        {
            "id": 254,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "What happens when converting a DataFrame with categorical data?",
            "options": [
                "Categories convert to codes (integers)",
                "Categories remain as strings",
                "Conversion fails",
                "Creates object array"
            ],
            "correct_answer": 0,
            "explanation": "Categorical data converts to integer codes in numpy array, losing category labels"
        },
        {
            "id": 255,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "Complete the code to convert Series to numpy and get shape:",
            "code_snippet": "shape = series.to_numpy().______",
            "options": [
                "shape",
                "size",
                "dim",
                "len"
            ],
            "correct_answer": 0,
            "explanation": "After conversion, use .shape attribute to get dimensions of numpy array"
        },
        {
            "id": 256,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "advanced",
            "question": "Which parameter controls memory order in to_numpy()?",
            "options": [
                "order",
                "memory_order",
                "copy",
                "C_order"
            ],
            "correct_answer": 0,
            "explanation": "order parameter controls memory layout: 'C' for row-major, 'F' for column-major"
        },
        {
            "id": 257,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "Complete the code to avoid copying data during conversion:",
            "code_snippet": "array = df.to_numpy(______=False)",
            "options": [
                "copy",
                "nocopy",
                "view",
                "share"
            ],
            "correct_answer": 0,
            "explanation": "copy=False attempts to return a view when possible to avoid data duplication"
        },
        {
            "id": 258,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "What is lost when converting DataFrame to numpy array?",
            "options": [
                "Column names and index",
                "Only column names",
                "Only index",
                "Data types"
            ],
            "correct_answer": 0,
            "explanation": "Both column names and index information are lost, only raw data remains"
        },
        {
            "id": 259,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "advanced",
            "question": "Complete the code to convert and preserve datetime as datetime64:",
            "code_snippet": "dt_array = df['Date'].to_numpy(______=None)",
            "options": [
                "dtype",
                "dtype_",
                "type",
                "convert_dates"
            ],
            "correct_answer": 0,
            "explanation": "dtype=None preserves original pandas dtypes like datetime64 in numpy"
        },
        {
            "id": 260,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "What is the performance benefit of pandas-numpy conversion?",
            "options": [
                "Enables low-level optimizations",
                "Reduces memory usage",
                "Automatic parallelization",
                "Compression"
            ],
            "correct_answer": 0,
            "explanation": "Numpy arrays enable low-level C/Fortran optimizations for numerical computations"
        },
        {
            "id": 261,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "Complete the code to verify array contents after conversion:",
            "code_snippet": "print(\"First element:\", array[______])",
            "options": [
                "0,0",
                "[0][0]",
                "0, 0",
                "(0,0)"
            ],
            "correct_answer": 0,
            "explanation": "For 2D numpy arrays, use [row, column] indexing: array[0,0] for first element"
        },
        {
            "id": 262,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "advanced",
            "question": "When does copy=False actually return a view in to_numpy()?",
            "options": [
                "When data is contiguous and dtypes match",
                "Always returns view",
                "Never returns view",
                "Only for numeric data"
            ],
            "correct_answer": 0,
            "explanation": "copy=False returns view only when data is contiguous in memory and dtypes are compatible"
        },
        {
            "id": 263,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "intermediate",
            "question": "Complete the code to convert single column to 1D array:",
            "code_snippet": "grades_array = df['Grade'].______()",
            "options": [
                "to_numpy",
                "values",
                "to_numpy() or values",
                "array"
            ],
            "correct_answer": 2,
            "explanation": "Both to_numpy() and .values convert Series to 1D numpy array"
        },
        {
            "id": 264,
            "type": "multiple_choice",
            "category": "pandas_numpy_conversion",
            "difficulty": "beginner",
            "question": "What is the shape of array from single-column DataFrame conversion?",
            "options": [
                "(n_rows, 1)",
                "(n_rows,)",
                "(1, n_rows)",
                "(n_rows, n_cols)"
            ],
            "correct_answer": 0,
            "explanation": "Single-column DataFrame converts to 2D array with shape (n_rows, 1)"
        },
        {
            "id": 265,
            "type": "code_completion",
            "category": "pandas_numpy_conversion",
            "difficulty": "advanced",
            "question": "Complete the code to handle NA values during conversion:",
            "code_snippet": "array = df.to_numpy(______=0)",
            "options": [
                "na_value",
                "fillna",
                "na_fill",
                "missing_value"
            ],
            "correct_answer": 0,
            "explanation": "na_value parameter specifies replacement for NA/missing values during conversion"
        },
        {
            "id": 266,
            "type": "multiple_choice",
            "category": "neural_networks_fundamentals",
            "difficulty": "beginner",
            "question": "What does AI being a 'mathematical approximation' of the real world mean?",
            "options": [
                "AI relies solely on predefined rules, making it inflexible and unable to learn from data",
                "AI tries to represent patterns in the real world using math",
                "AI works only when the data is perfect",
                "AI copies the exact behavior of humans"
            ],
            "correct_answer": 1,
            "explanation": "AI models use mathematical structures to capture and represent patterns found in real-world data, creating approximate models rather than exact replicas of reality."
        },
        {
            "id": 267,
            "type": "multiple_choice",
            "category": "neural_networks_fundamentals",
            "difficulty": "beginner",
            "question": "What is the key difference between designing a microprocessor and training a neural network?",
            "options": [
                "Microprocessors are built with fixed instructions, while neural networks learn from data",
                "Microprocessors use more data",
                "Neural networks are fully hand-coded",
                "Neural networks never need any structure"
            ],
            "correct_answer": 0,
            "explanation": "Microprocessors execute predefined instructions with fixed behavior, while neural networks learn patterns from data through training and adjust their weights accordingly."
        },
        {
            "id": 268,
            "type": "multiple_choice",
            "category": "neural_networks_fundamentals",
            "difficulty": "beginner",
            "question": "What is the role of an artificial neuron in a Neural Network?",
            "options": [
                "Store large datasets",
                "Process inputs and generate outputs based on a weighted sum of the inputs and activation functions",
                "Control hardware devices",
                "Transmit data over long distances on the internet"
            ],
            "correct_answer": 1,
            "explanation": "An artificial neuron processes inputs by multiplying them by weights, summing them with a bias, and passing the result through an activation function to produce an output."
        },
        {
            "id": 269,
            "type": "multiple_choice",
            "category": "neural_networks_fundamentals",
            "difficulty": "intermediate",
            "question": "What happens if a neural network only uses linear functions throughout?",
            "options": [
                "It becomes equivalent to performing simple linear regression",
                "It can perform complex, non-linear tasks",
                "It can simulate brain activity perfectly",
                "It can achieve high accuracy on all types of data without any additional tuning"
            ],
            "correct_answer": 0,
            "explanation": "Without non-linear activation functions, the entire network reduces to a single linear transformation, equivalent to linear regression and unable to learn complex patterns."
        },
        {
            "id": 270,
            "type": "multiple_choice",
            "category": "neural_networks_fundamentals",
            "difficulty": "intermediate",
            "question": "Why is nonlinearity important in a neural network?",
            "options": [
                "It reduces the number of inputs required",
                "It makes the network faster to train",
                "It allows the network to learn more complex patterns and functions",
                "It helps the network perform simple linear regression"
            ],
            "correct_answer": 2,
            "explanation": "Nonlinear activation functions enable neural networks to model complex, non-linear relationships in data that linear models cannot capture."
        },
        {
            "id": 271,
            "type": "multiple_choice",
            "category": "neural_networks_fundamentals",
            "difficulty": "intermediate",
            "question": "How does bias affect the output of a neuron in a Neural Network?",
            "options": [
                "They change the input values",
                "They adjust the weighted sum before applying the activation function",
                "They determine the number of neurons in a hidden layer",
                "They are irrelevant to the output calculation"
            ],
            "correct_answer": 1,
            "explanation": "Bias is an additive constant that shifts the weighted sum before it passes through the activation function, improving the model's flexibility to fit data."
        },
        {
            "id": 272,
            "type": "multiple_choice",
            "category": "neural_networks_architecture",
            "difficulty": "beginner",
            "question": "What is a multi-layer perceptron (MLP)?",
            "options": [
                "A single-layer neural network that can only classify data",
                "A network of neurons that requires no training",
                "A type of decision tree model used in Machine Learning",
                "A network of connected neurons arranged in multiple layers for solving complex problems"
            ],
            "correct_answer": 3,
            "explanation": "MLP is a feedforward neural network with input, hidden, and output layers that can learn non-linear relationships through backpropagation."
        },
        {
            "id": 273,
            "type": "multiple_choice",
            "category": "neural_networks_architecture",
            "difficulty": "beginner",
            "question": "How are the layers in a neural network typically structured?",
            "options": [
                "The network uses layers, but only randomly connects neurons",
                "Only one layer of neurons is used",
                "Only an input layer and an output layer are necessary",
                "There are input, hidden, and output layers, with one or more neurons in each layer"
            ],
            "correct_answer": 3,
            "explanation": "Standard neural networks have input layers for data reception, hidden layers for computation, and output layers for final predictions."
        },
        {
            "id": 274,
            "type": "multiple_choice",
            "category": "training_fundamentals",
            "difficulty": "beginner",
            "question": "In one sentence, describe what is an epoch in the context of training a Neural Network?",
            "options": [
                "An epoch is one complete pass of the entire training dataset through the neural network during the training process.",
                "An epoch is the time it takes to process one batch of data through the network.",
                "An epoch is the final accuracy achieved after training is complete.",
                "An epoch is the initial random initialization of the network weights."
            ],
            "correct_answer": 0,
            "explanation": "An epoch represents one full cycle through the entire training dataset, allowing the model to learn from all available training examples."
        },
        {
            "id": 275,
            "type": "multiple_choice",
            "category": "training_fundamentals",
            "difficulty": "intermediate",
            "question": "What is one major risk of training a model on noisy data?",
            "options": [
                "The model becomes simpler",
                "The model may overfit and perform poorly on new data",
                "The model trains faster",
                "The model requires less memory"
            ],
            "correct_answer": 1,
            "explanation": "Noisy data can cause overfitting, where the model learns noise rather than underlying patterns, leading to poor generalization on new data."
        },
        {
            "id": 276,
            "type": "multiple_choice",
            "category": "training_fundamentals",
            "difficulty": "intermediate",
            "question": "What is the purpose of batch training?",
            "options": [
                "To break data into smaller parts for efficient learning",
                "To increase file size",
                "To delete unnecessary data",
                "To train all the data at once"
            ],
            "correct_answer": 0,
            "explanation": "Batch training divides data into smaller subsets for more efficient memory usage, frequent weight updates, and better convergence during training."
        },
        {
            "id": 277,
            "type": "multiple_choice",
            "category": "model_comparison",
            "difficulty": "beginner",
            "question": "Which best describes a key difference between linear regression and Neural Networks?",
            "options": [
                "Linear regression can handle complex, nonlinear relationships",
                "Neural Networks are ideal for simple tasks with a single variable",
                "Linear regression is suited for linear relationships, while Neural Networks can model complex patterns",
                "Neural Networks are always faster to train than linear regression models"
            ],
            "correct_answer": 2,
            "explanation": "Linear regression assumes linear relationships, while neural networks with non-linear activations can capture complex, non-linear patterns in data."
        },
        {
            "id": 278,
            "type": "true_false",
            "category": "model_comparison",
            "difficulty": "beginner",
            "question": "Linear regression models predict continuous outcomes by fitting lines to data, while Neural Networks handle complex patterns through interconnected nodes.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "This statement accurately distinguishes linear regression's linear modeling approach from neural networks' ability to capture complex, non-linear patterns."
        },
        {
            "id": 279,
            "type": "multiple_choice",
            "category": "training_fundamentals",
            "difficulty": "intermediate",
            "question": "What is the purpose of the Loss Function in neural network training?",
            "options": [
                "To adjust the network's architecture",
                "To calculate the total number of neurons in the network",
                "To measure the difference between predicted values and actual data during training",
                "To increase the number of parameters"
            ],
            "correct_answer": 2,
            "explanation": "The loss function quantifies prediction errors and provides the feedback signal for optimizing model weights during training."
        },
        {
            "id": 280,
            "type": "true_false",
            "category": "neural_networks_fundamentals",
            "difficulty": "beginner",
            "question": "Changing the weight of a neuron results in a change in the prediction value.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "Weights determine connection strengths between neurons, and changing them alters the network's computations and final predictions."
        },
        {
            "id": 281,
            "type": "multiple_choice",
            "category": "mnist_basics",
            "difficulty": "beginner",
            "question": "How many input nodes does the MNIST neural network have?",
            "options": [
                "64",
                "10",
                "784",
                "28"
            ],
            "correct_answer": 2,
            "explanation": "The MNIST network has 784 input nodes, corresponding to the 28x28 pixels in each handwritten digit image."
        },
        {
            "id": 282,
            "type": "multiple_choice",
            "category": "mnist_basics",
            "difficulty": "beginner",
            "question": "How many output nodes does the MNIST neural network have?",
            "options": [
                "64",
                "10",
                "784",
                "28"
            ],
            "correct_answer": 1,
            "explanation": "The MNIST network has 10 output nodes, each representing one digit class from 0 to 9."
        },
        {
            "id": 283,
            "type": "multiple_choice",
            "category": "problem_types",
            "difficulty": "beginner",
            "question": "What type of problem is the MNIST dataset used for?",
            "options": [
                "Regression",
                "Classification",
                "Clustering",
                "Reinforcement Learning"
            ],
            "correct_answer": 1,
            "explanation": "MNIST is a classification problem where the goal is to assign each image to one of 10 digit classes."
        },
        {
            "id": 284,
            "type": "multiple_choice",
            "category": "problem_types",
            "difficulty": "beginner",
            "question": "What is the key difference between classification and regression?",
            "options": [
                "Classification predicts continuous values, regression predicts categories",
                "Classification predicts categories, regression predicts continuous values",
                "Classification uses neural networks, regression uses decision trees",
                "Classification is faster, regression is more accurate"
            ],
            "correct_answer": 1,
            "explanation": "Classification predicts discrete categories/labels, while regression predicts continuous numerical values."
        },
        {
            "id": 285,
            "type": "multiple_choice",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "What is the purpose of one-hot encoding?",
            "options": [
                "To reduce the dataset size",
                "To convert text to lowercase",
                "To convert categorical data into a numeric format",
                "To normalize numeric data"
            ],
            "correct_answer": 2,
            "explanation": "One-hot encoding converts categorical labels into binary vectors, allowing ML models to work with categorical data without assuming ordinal relationships."
        },
        {
            "id": 286,
            "type": "multiple_choice",
            "category": "model_outputs",
            "difficulty": "intermediate",
            "question": "What do the output probabilities from a neural network represent?",
            "options": [
                "The model's confidence level for each possible class",
                "The model is unsure about the input",
                "The model is overfitting",
                "The frequency of each class in the dataset"
            ],
            "correct_answer": 0,
            "explanation": "Output probabilities represent the model's confidence or likelihood that the input belongs to each class, with all probabilities summing to 1."
        },
        {
            "id": 287,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "What is the purpose of the Softmax function?",
            "options": [
                "To convert inputs into a continuous range",
                "To apply random values to the outputs",
                "To scale the inputs to a common range",
                "To ensure output values are between 0 and 1 and sum to 1"
            ],
            "correct_answer": 3,
            "explanation": "Softmax converts raw output scores into probabilities that sum to 1, making them interpretable as confidence levels for each class."
        },
        {
            "id": 288,
            "type": "multiple_choice",
            "category": "training_process",
            "difficulty": "intermediate",
            "question": "How many images are typically used for training in the MNIST dataset?",
            "options": [
                "10,000",
                "50,000",
                "60,000",
                "70,000"
            ],
            "correct_answer": 2,
            "explanation": "The standard MNIST dataset uses 60,000 images for training and 10,000 images for testing."
        },
        {
            "id": 289,
            "type": "multiple_choice",
            "category": "training_process",
            "difficulty": "intermediate",
            "question": "What accuracy indicates a well-trained MNIST network?",
            "options": [
                "10%",
                "50%",
                "80%",
                "95%"
            ],
            "correct_answer": 3,
            "explanation": "Achieving around 95% accuracy on the test set indicates the network has effectively learned to classify handwritten digits, significantly better than random guessing (10%)."
        },
        {
            "id": 290,
            "type": "true_false",
            "category": "mnist_basics",
            "difficulty": "beginner",
            "question": "Neural Networks can process the MNIST dataset to recognize handwritten digits by learning complex patterns.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "Neural networks learn to recognize digits by identifying patterns like edges, curves, and shapes from pixel inputs through training."
        },
        {
            "id": 291,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "What is the common activation function in the output layer for binary classification problems?",
            "options": [
                "ReLU",
                "Linear",
                "Softmax",
                "Sigmoid"
            ],
            "correct_answer": 3,
            "explanation": "Sigmoid is used for binary classification as it outputs values between 0 and 1 that can be interpreted as probabilities for the positive class."
        },
        {
            "id": 292,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "When should a neural network typically use the ReLU activation function?",
            "options": [
                "In the output layer for binary classification",
                "In the hidden layers, irrespective of problem type",
                "In the output layer for multi-class classification",
                "In the output layer for regression problems with non-negative targets"
            ],
            "correct_answer": 1,
            "explanation": "ReLU is most commonly used in hidden layers across various problem types due to its efficiency and ability to mitigate vanishing gradient problems."
        },
        {
            "id": 293,
            "type": "multiple_choice",
            "category": "neural_network_types",
            "difficulty": "intermediate",
            "question": "Which type of Neural Network is specifically designed to process sequential data like text or time series?",
            "options": [
                "Multi-Layer Perceptron (MLP)",
                "Convolutional Neural Network (CNN)",
                "Recurrent Neural Network (RNN)",
                "Autoencoder"
            ],
            "correct_answer": 2,
            "explanation": "RNNs are designed for sequential data with memory capabilities that allow them to process inputs where order matters, like text or time series."
        },
        {
            "id": 294,
            "type": "true_false",
            "category": "neural_network_types",
            "difficulty": "intermediate",
            "question": "Convolutional Neural Networks (CNN) are specialized for processing grid-like data such as images, using convolutional layers to detect spatial patterns.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "CNNs use convolutional and pooling layers to efficiently recognize spatial hierarchies and patterns in grid-like data such as images."
        },
        {
            "id": 295,
            "type": "multiple_choice",
            "category": "neural_network_types",
            "difficulty": "intermediate",
            "question": "Which architecture is commonly used for image recognition tasks?",
            "options": [
                "Recurrent Neural Networks (RNNs)",
                "Long Short-Term Memory (LSTM) Networks",
                "Convolutional Neural Networks (CNNs)",
                "Rule-Based System"
            ],
            "correct_answer": 2,
            "explanation": "CNNs are specifically designed for image recognition with convolutional layers that detect spatial patterns and hierarchical features in images."
        },
        {
            "id": 296,
            "type": "multiple_choice",
            "category": "neural_network_types",
            "difficulty": "intermediate",
            "question": "What type of neural network architecture is best for tasks involving sequences or time series data?",
            "options": [
                "Recurrent Neural Networks (RNNs)",
                "Autoencoders",
                "Deep Neural Networks (DNNs)",
                "Convolutional Neural Networks (CNNs)"
            ],
            "correct_answer": 0,
            "explanation": "RNNs are specifically designed for sequential data like time series, text, or speech because they have feedback connections that allow information to persist and maintain memory of previous elements."
        },
        {
            "id": 297,
            "type": "multiple_choice",
            "category": "neural_network_types",
            "difficulty": "advanced",
            "question": "What is a key feature of Long Short-Term Memory (LSTM) networks compared to regular RNNs?",
            "options": [
                "They are faster to train",
                "They use convolutional layers for better image processing",
                "They do not require data preprocessing",
                "They have enhanced memory capabilities to learn which information to retain or forget over long sequences"
            ],
            "correct_answer": 3,
            "explanation": "LSTMs have gating mechanisms (input, forget, and output gates) that allow them to selectively remember important information and forget irrelevant details over long sequences, solving the vanishing gradient problem of regular RNNs."
        },
        {
            "id": 298,
            "type": "true_false",
            "category": "neural_network_types",
            "difficulty": "advanced",
            "question": "Long Short-Term Memory (LSTM) is a type of RNN that handles long-term dependencies more effectively, suited for tasks requiring memory of past inputs over extended sequences.",
            "options": [
                "False",
                "True"
            ],
            "correct_answer": 1,
            "explanation": "LSTMs use gating mechanisms to control information flow, allowing them to remember important information over long periods and solve the vanishing gradient problem in standard RNNs."
        },
        {
            "id": 299,
            "type": "true_false",
            "category": "neural_network_types",
            "difficulty": "advanced",
            "question": "An Autoencoder is a type of Neural Network designed for unsupervised learning that compresses input data into lower-dimensional representations and reconstructs the output, useful for dimensionality reduction and anomaly detection.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "Autoencoders consist of encoder and decoder components that learn efficient data representations through compression and reconstruction, making them valuable for dimensionality reduction and anomaly detection tasks."
        },
        {
            "id": 300,
            "type": "multiple_choice",
            "category": "mnist_dataset",
            "difficulty": "beginner",
            "question": "What is the range of pixel values in the MNIST dataset after scaling images using division by 255?",
            "options": [
                "[0, 255]",
                "[0, 1]",
                "[-1, 1]",
                "[-255, 255]"
            ],
            "correct_answer": 1,
            "explanation": "Dividing original pixel values (0-255) by 255 scales them to the range [0, 1], which is a common normalization technique that helps neural networks train faster and more stably."
        },
        {
            "id": 301,
            "type": "multiple_choice",
            "category": "mnist_dataset",
            "difficulty": "intermediate",
            "question": "Which of the following statements about the MNIST dataset is true?",
            "options": [
                "It contains 100,000 handwritten images of digits 0-9",
                "Each image is 32x32 pixels with values between 0-1",
                "The dataset is only used for image classification",
                "None of the above are fully correct"
            ],
            "correct_answer": 3,
            "explanation": "MNIST has 70,000 images (not 100,000), images are 28x28 pixels (not 32x32), and while primarily for classification, it's also used for other tasks like generative modeling and anomaly detection."
        },
        {
            "id": 302,
            "type": "true_false",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "In TensorFlow, the variable num_classes must equal the number of unique classes in the dataset for one-hot encoding to work correctly.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "If num_classes is less than actual unique classes, some classes won't get encoded properly; if greater, it creates unnecessary extra columns. For MNIST, num_classes=10 matches the 10 digit classes."
        },
        {
            "id": 303,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "What is the activation function used in the output layer for the MNIST dataset?",
            "options": [
                "Sigmoid",
                "ReLU",
                "Softmax",
                "Linear"
            ],
            "correct_answer": 2,
            "explanation": "Softmax is used for multi-class classification problems like MNIST (10 digit classes) because it converts output scores into probabilities that sum to 1, with each output node representing a digit class probability."
        },
        {
            "id": 304,
            "type": "multiple_choice",
            "category": "tensorflow_basics",
            "difficulty": "intermediate",
            "question": "Which of the following is true while compiling the model in TensorFlow?",
            "options": [
                "We initialize the model with random weights",
                "We define the architecture of the model",
                "We specify the loss function and optimizer for training",
                "We evaluate the model on the test data"
            ],
            "correct_answer": 2,
            "explanation": "model.compile() configures the learning process by specifying the loss function, optimizer, and metrics. Weights are initialized when layers are created, architecture is defined during model building, and evaluation happens after training."
        },
        {
            "id": 305,
            "type": "calculation",
            "category": "training_process",
            "difficulty": "advanced",
            "question": "Given a dataset of 1000 rows, batch size of 10, and 10 epochs, how many weight updates occur during training?",
            "options": [
                "100",
                "1000",
                "10000",
                "10"
            ],
            "correct_answer": 1,
            "explanation": "Batches per epoch = 1000/10 = 100. Weight updates per epoch = 100. Total updates = 100 Ã 10 = 1000. Each batch processing results in one weight update via backpropagation."
        },
        {
            "id": 306,
            "type": "true_false",
            "category": "training_process",
            "difficulty": "intermediate",
            "question": "Increasing the number of epochs results in a proportional increase in the time taken to train the model.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "While not perfectly proportional due to hardware optimizations and convergence variations, doubling epochs typically roughly doubles training time since the model processes the entire dataset more times."
        },
        {
            "id": 307,
            "type": "calculation",
            "category": "neural_network_architecture",
            "difficulty": "intermediate",
            "question": "How many hidden layers are present in a neural network with: Dense(128), Dense(64), Dense(10) layers?",
            "options": [
                "1",
                "2",
                "3",
                "4"
            ],
            "correct_answer": 1,
            "explanation": "The first Dense(128) and second Dense(64) layers are hidden layers, while Dense(10) is the output layer. Input layer is implicit from input_dim parameter."
        },
        {
            "id": 308,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "Which activation function is characterized by an S-shaped curve mapping inputs to 0-1 range?",
            "options": [
                "ReLU",
                "Sigmoid",
                "Tanh",
                "Linear"
            ],
            "correct_answer": 1,
            "explanation": "Sigmoid has an S-shaped curve that squashes inputs to the range (0,1), making it suitable for binary classification outputs interpretable as probabilities."
        },
        {
            "id": 309,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "Which activation function maps inputs to the range -1 to 1 and helps center data around zero?",
            "options": [
                "ReLU",
                "Sigmoid",
                "Tanh",
                "Softmax"
            ],
            "correct_answer": 2,
            "explanation": "Tanh (hyperbolic tangent) transforms inputs to (-1,1) range, providing zero-centered outputs that can speed up convergence during training compared to sigmoid."
        },
        {
            "id": 310,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "Which activation function outputs the input directly if positive, otherwise outputs zero?",
            "options": [
                "Sigmoid",
                "Tanh",
                "ReLU",
                "Linear"
            ],
            "correct_answer": 2,
            "explanation": "ReLU (Rectified Linear Unit) outputs max(0,input), making it computationally efficient and effective at mitigating vanishing gradient problems in hidden layers."
        },
        {
            "id": 311,
            "type": "multiple_choice",
            "category": "activation_functions",
            "difficulty": "advanced",
            "question": "What problem does Leaky ReLU address that can occur with standard ReLU?",
            "options": [
                "Vanishing gradient problem",
                "Exploding gradients",
                "Dying ReLU problem",
                "Overfitting"
            ],
            "correct_answer": 2,
            "explanation": "Leaky ReLU addresses the 'dying ReLU' problem where neurons can become permanently inactive by allowing a small, non-zero gradient for negative inputs."
        },
        {
            "id": 312,
            "type": "true_false",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "The step function is a simple threshold-based activation function with binary outputs.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "The step function outputs 1 if input exceeds a threshold, otherwise 0, making it the simplest activation function but limited for modern neural networks."
        },
        {
            "id": 313,
            "type": "multiple_choice",
            "category": "layer_selection",
            "difficulty": "intermediate",
            "question": "Which activation function is generally avoided in hidden layers because it doesn't introduce non-linearity?",
            "options": [
                "ReLU",
                "Sigmoid",
                "Linear",
                "Tanh"
            ],
            "correct_answer": 2,
            "explanation": "Linear activation functions don't introduce non-linearity, making deep networks equivalent to single-layer networks and unable to learn complex patterns."
        },
        {
            "id": 314,
            "type": "multiple_choice",
            "category": "layer_selection",
            "difficulty": "intermediate",
            "question": "For which type of problem would you use linear activation in the output layer?",
            "options": [
                "Binary classification",
                "Multi-class classification",
                "Regression with continuous outputs",
                "Image segmentation"
            ],
            "correct_answer": 2,
            "explanation": "Linear activation is suitable for regression problems where the output needs to be a continuous value without range restrictions."
        },
        {
            "id": 315,
            "type": "true_false",
            "category": "activation_functions",
            "difficulty": "intermediate",
            "question": "Tanh activation function outputs are zero-centered, which can make learning faster and more stable in some neural networks.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "Tanh's output range of (-1,1) is zero-centered, which often helps speed up convergence during training compared to sigmoid's (0,1) range."
        },
        {
            "id": 316,
            "type": "code_completion",
            "category": "tensorflow_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a Sequential model in Keras:",
            "code_snippet": "model = ______()",
            "options": [
                "Sequential",
                "Model",
                "Network",
                "Keras"
            ],
            "correct_answer": 0,
            "explanation": "Sequential() creates a linear stack of layers in Keras/TensorFlow, which is the simplest way to build neural network models."
        },
        {
            "id": 317,
            "type": "code_completion",
            "category": "tensorflow_basics",
            "difficulty": "beginner",
            "question": "Complete the code to add a Dense layer with 64 units and ReLU activation:",
            "code_snippet": "model.add(______(64, activation='relu'))",
            "options": [
                "Dense",
                "Layer",
                "Neural",
                "Linear"
            ],
            "correct_answer": 0,
            "explanation": "Dense() creates a fully connected layer in Keras, where all neurons in the current layer connect to all neurons in the next layer."
        },
        {
            "id": 318,
            "type": "code_completion",
            "category": "tensorflow_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to compile a model with Adam optimizer and categorical crossentropy loss:",
            "code_snippet": "model.compile(optimizer='______', loss='categorical_crossentropy', metrics=['accuracy'])",
            "options": [
                "adam",
                "sgd",
                "rmsprop",
                "adagrad"
            ],
            "correct_answer": 0,
            "explanation": "'adam' is a popular optimizer that combines benefits of RMSProp and Momentum, often providing good performance with default parameters."
        },
        {
            "id": 319,
            "type": "multiple_choice",
            "category": "training_process",
            "difficulty": "intermediate",
            "question": "What does the loss function measure during neural network training?",
            "options": [
                "The speed of training",
                "The difference between predictions and actual values",
                "The number of parameters in the model",
                "The learning rate efficiency"
            ],
            "correct_answer": 1,
            "explanation": "The loss function quantifies how well the model's predictions match the true target values, providing the feedback signal for weight updates during training."
        },
        {
            "id": 320,
            "type": "multiple_choice",
            "category": "optimization",
            "difficulty": "intermediate",
            "question": "What is the role of the optimizer in neural network training?",
            "options": [
                "To initialize random weights",
                "To determine how weights are updated based on the loss",
                "To select the best activation functions",
                "To preprocess the input data"
            ],
            "correct_answer": 1,
            "explanation": "The optimizer determines how the model's weights are updated based on the loss gradient, using algorithms like gradient descent, Adam, or RMSProp."
        },
        {
            "id": 321,
            "type": "multiple_choice",
            "category": "evaluation",
            "difficulty": "beginner",
            "question": "What does model.evaluate() return in Keras?",
            "options": [
                "The model architecture",
                "The loss value and metrics values on test data",
                "The training history",
                "The optimized weights"
            ],
            "correct_answer": 1,
            "explanation": "model.evaluate() returns the loss value and any specified metrics (like accuracy) calculated on the provided test dataset."
        },
        {
            "id": 322,
            "type": "multiple_choice",
            "category": "data_splitting",
            "difficulty": "intermediate",
            "question": "Why is the test set kept separate from the training set?",
            "options": [
                "To make training faster",
                "To evaluate model performance on unseen data",
                "To reduce memory usage",
                "To increase model complexity"
            ],
            "correct_answer": 1,
            "explanation": "The test set provides unbiased evaluation on data the model hasn't seen during training, helping assess real-world generalization performance."
        },
        {
            "id": 323,
            "type": "multiple_choice",
            "category": "overfitting",
            "difficulty": "intermediate",
            "question": "What indicates that a model is overfitting?",
            "options": [
                "High training accuracy and high test accuracy",
                "Low training accuracy and low test accuracy",
                "High training accuracy and low test accuracy",
                "Consistent accuracy across all datasets"
            ],
            "correct_answer": 2,
            "explanation": "Overfitting occurs when a model performs well on training data but poorly on unseen test data, indicating it memorized noise rather than learning general patterns."
        },
        {
            "id": 324,
            "type": "multiple_choice",
            "category": "regularization",
            "difficulty": "advanced",
            "question": "Which technique can help prevent overfitting in neural networks?",
            "options": [
                "Increasing model complexity",
                "Training for more epochs",
                "Using dropout regularization",
                "Removing the test set"
            ],
            "correct_answer": 2,
            "explanation": "Dropout randomly disables neurons during training, preventing over-reliance on specific neurons and encouraging more robust feature learning."
        },
        {
            "id": 325,
            "type": "multiple_choice",
            "category": "training_process",
            "difficulty": "advanced",
            "question": "What is the purpose of validation data during training?",
            "options": [
                "To replace the test set",
                "To monitor overfitting and tune hyperparameters during training",
                "To increase the training dataset size",
                "To speed up training convergence"
            ],
            "correct_answer": 1,
            "explanation": "Validation data provides ongoing evaluation during training to monitor for overfitting and helps tune hyperparameters without touching the final test set."
        },
        {
            "id": 326,
            "type": "multiple_choice",
            "category": "gradient_descent",
            "difficulty": "intermediate",
            "question": "What is the primary purpose of gradient descent in neural network training?",
            "options": [
                "To initialize weights randomly",
                "To minimize the loss function by updating weights",
                "To select the best activation functions",
                "To normalize input data"
            ],
            "correct_answer": 1,
            "explanation": "Gradient descent iteratively updates model weights in the direction that reduces the loss function, gradually minimizing prediction errors during training."
        },
        {
            "id": 327,
            "type": "multiple_choice",
            "category": "gradient_descent",
            "difficulty": "advanced",
            "question": "What is the vanishing gradient problem?",
            "options": [
                "Gradients become too large and cause unstable training",
                "Gradients become very small and slow down learning in early layers",
                "Gradients disappear completely after one epoch",
                "Gradients change direction randomly"
            ],
            "correct_answer": 1,
            "explanation": "In deep networks, gradients can become extremely small during backpropagation, causing early layers to learn very slowly or stop learning altogether."
        },
        {
            "id": 328,
            "type": "multiple_choice",
            "category": "optimizers",
            "difficulty": "advanced",
            "question": "How does the Adam optimizer differ from basic gradient descent?",
            "options": [
                "It doesn't use gradients at all",
                "It combines momentum and adaptive learning rates for each parameter",
                "It only works for convolutional networks",
                "It requires manual learning rate tuning for each layer"
            ],
            "correct_answer": 1,
            "explanation": "Adam combines ideas from Momentum (acceleration in consistent directions) and RMSProp (adaptive learning rates per parameter), making it efficient and requiring less manual tuning."
        },
        {
            "id": 329,
            "type": "code_completion",
            "category": "tensorflow_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to train a model for 10 epochs with batch size 32:",
            "code_snippet": "history = model.fit(x_train, y_train, epochs=______, batch_size=32)",
            "options": [
                "10",
                "32",
                "100",
                "0.1"
            ],
            "correct_answer": 0,
            "explanation": "The epochs parameter specifies how many times the model will iterate over the entire training dataset during the training process."
        },
        {
            "id": 330,
            "type": "multiple_choice",
            "category": "loss_functions",
            "difficulty": "intermediate",
            "question": "Which loss function is commonly used for multi-class classification problems?",
            "options": [
                "Mean Squared Error",
                "Binary Crossentropy",
                "Categorical Crossentropy",
                "Absolute Error"
            ],
            "correct_answer": 2,
            "explanation": "Categorical Crossentropy is used for multi-class classification where each sample belongs to exactly one class, measuring the difference between predicted probability distribution and true distribution."
        },
        {
            "id": 331,
            "type": "multiple_choice",
            "category": "loss_functions",
            "difficulty": "intermediate",
            "question": "When would you use binary crossentropy loss?",
            "options": [
                "For regression problems",
                "For multi-class classification with 10+ classes",
                "For binary classification problems",
                "For unsupervised learning"
            ],
            "correct_answer": 2,
            "explanation": "Binary crossentropy is designed for binary classification tasks where there are only two possible output classes (e.g., spam/not spam, cat/dog)."
        },
        {
            "id": 332,
            "type": "multiple_choice",
            "category": "metrics",
            "difficulty": "beginner",
            "question": "What does accuracy metric measure in classification tasks?",
            "options": [
                "The average distance from predictions to true values",
                "The proportion of correct predictions",
                "The speed of training",
                "The model complexity"
            ],
            "correct_answer": 1,
            "explanation": "Accuracy calculates the percentage of correct predictions out of all predictions made, providing a straightforward measure of classification performance."
        },
        {
            "id": 333,
            "type": "true_false",
            "category": "data_preprocessing",
            "difficulty": "intermediate",
            "question": "Normalizing input data to a common range (like 0-1) can help neural networks train faster and more stably.",
            "options": [
                "True",
                "False"
            ],
            "correct_answer": 0,
            "explanation": "Normalization prevents features with large scales from dominating the learning process and helps gradient-based optimization converge faster."
        },
        {
            "id": 334,
            "type": "multiple_choice",
            "category": "initialization",
            "difficulty": "advanced",
            "question": "Why is proper weight initialization important in neural networks?",
            "options": [
                "To make the model deterministic",
                "To prevent gradients from vanishing or exploding during early training",
                "To reduce the number of parameters",
                "To eliminate the need for bias terms"
            ],
            "correct_answer": 1,
            "explanation": "Proper initialization (like He or Xavier initialization) sets initial weights to appropriate scales that prevent gradients from becoming too small or too large during early training stages."
        },
        {
            "id": 335,
            "type": "multiple_choice",
            "category": "backpropagation",
            "difficulty": "advanced",
            "question": "What is the chain rule used for in backpropagation?",
            "options": [
                "To initialize network weights",
                "To calculate gradients through multiple layers",
                "To select learning rates",
                "To normalize input data"
            ],
            "correct_answer": 1,
            "explanation": "The chain rule from calculus allows backpropagation to compute gradients for early layers by multiplying gradients from subsequent layers, enabling efficient gradient calculation through deep networks."
        },
        {
            "id": 336,
            "type": "multiple_choice",
            "category": "batch_training",
            "difficulty": "intermediate",
            "question": "What is the advantage of using smaller batch sizes during training?",
            "options": [
                "More accurate gradient estimates",
                "Faster computation per update",
                "More frequent weight updates and better generalization",
                "Lower memory requirements"
            ],
            "correct_answer": 2,
            "explanation": "Smaller batches provide more frequent weight updates and can help escape local minima, often leading to better generalization despite noisier gradient estimates."
        },
        {
            "id": 337,
            "type": "multiple_choice",
            "category": "batch_training",
            "difficulty": "intermediate",
            "question": "What is stochastic gradient descent (SGD)?",
            "options": [
                "Gradient descent with batch size equal to the entire dataset",
                "Gradient descent with batch size of 1",
                "Gradient descent with adaptive learning rates",
                "Gradient descent with momentum"
            ],
            "correct_answer": 1,
            "explanation": "Stochastic Gradient Descent uses a batch size of 1, updating weights after each individual training sample, providing very frequent updates but noisy gradients."
        },
        {
            "id": 338,
            "type": "multiple_choice",
            "category": "learning_rate",
            "difficulty": "intermediate",
            "question": "What happens if the learning rate is set too high?",
            "options": [
                "Training becomes very slow",
                "The model may converge to a poor solution or diverge",
                "Gradients become zero",
                "The model stops learning after first epoch"
            ],
            "correct_answer": 1,
            "explanation": "Too high learning rate causes large weight updates that can overshoot the optimal solution, leading to oscillation around the minimum or complete divergence."
        },
        {
            "id": 339,
            "type": "multiple_choice",
            "category": "learning_rate",
            "difficulty": "intermediate",
            "question": "What happens if the learning rate is set too low?",
            "options": [
                "Training becomes very fast",
                "The model may get stuck in local minima",
                "Training becomes very slow and may not converge in reasonable time",
                "Gradients explode"
            ],
            "correct_answer": 2,
            "explanation": "Too low learning rate results in very small weight updates, making training extremely slow and potentially preventing convergence within practical time limits."
        },
        {
            "id": 340,
            "type": "multiple_choice",
            "category": "regularization",
            "difficulty": "advanced",
            "question": "What is L2 regularization (weight decay)?",
            "options": [
                "Adding a penalty proportional to the absolute value of weights",
                "Adding a penalty proportional to the square of weights",
                "Randomly dropping neurons during training",
                "Stopping training early when validation performance stops improving"
            ],
            "correct_answer": 1,
            "explanation": "L2 regularization adds a penalty term proportional to the square of the weights to the loss function, encouraging smaller weights and reducing overfitting."
        },
        {
            "id": 341,
            "type": "multiple_choice",
            "category": "regularization",
            "difficulty": "advanced",
            "question": "How does dropout regularization work during training?",
            "options": [
                "It removes entire layers from the network",
                "It randomly sets a fraction of input units to 0 at each update",
                "It reduces the learning rate over time",
                "It adds noise to the input data"
            ],
            "correct_answer": 1,
            "explanation": "Dropout randomly disables a percentage of neurons during each training iteration, preventing complex co-adaptations and making the network more robust."
        },
        {
            "id": 342,
            "type": "multiple_choice",
            "category": "early_stopping",
            "difficulty": "intermediate",
            "question": "What is the purpose of early stopping in neural network training?",
            "options": [
                "To speed up the initial training phase",
                "To prevent overfitting by stopping when validation performance degrades",
                "To ensure all weights are properly initialized",
                "To automatically select the best optimizer"
            ],
            "correct_answer": 1,
            "explanation": "Early stopping monitors validation performance and halts training when it starts to degrade, preventing the model from overfitting to the training data."
        },
        {
            "id": 343,
            "type": "multiple_choice",
            "category": "callbacks",
            "difficulty": "intermediate",
            "question": "In Keras, what is the purpose of the ModelCheckpoint callback?",
            "options": [
                "To periodically save the model during training",
                "To check the model architecture for errors",
                "To validate input data format",
                "To optimize the learning rate"
            ],
            "correct_answer": 0,
            "explanation": "ModelCheckpoint callback saves the model weights (or entire model) at specified intervals, allowing recovery of the best model or resuming training from checkpoints."
        },
        {
            "id": 344,
            "type": "code_completion",
            "category": "tensorflow_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to add dropout regularization to a layer:",
            "code_snippet": "model.add(______(0.2))",
            "options": [
                "Dropout",
                "Regularization",
                "Noise",
                "Skip"
            ],
            "correct_answer": 0,
            "explanation": "Dropout(0.2) adds a dropout layer that randomly sets 20% of input units to 0 during training, helping prevent overfitting."
        },
        {
            "id": 345,
            "type": "multiple_choice",
            "category": "batch_normalization",
            "difficulty": "advanced",
            "question": "What is the main benefit of batch normalization?",
            "options": [
                "Reduces the number of model parameters",
                "Faster and more stable training by normalizing layer inputs",
                "Eliminates the need for activation functions",
                "Automatically selects the optimal learning rate"
            ],
            "correct_answer": 1,
            "explanation": "Batch normalization normalizes the inputs to each layer, reducing internal covariate shift and allowing higher learning rates and faster, more stable training."
        },
        {
            "id": 346,
            "type": "multiple_choice",
            "category": "convolutional_networks",
            "difficulty": "intermediate",
            "question": "What is the primary purpose of convolutional layers in CNNs?",
            "options": [
                "To process sequential data",
                "To detect spatial patterns and features in images",
                "To reduce model size",
                "To increase training speed"
            ],
            "correct_answer": 1,
            "explanation": "Convolutional layers use filters to detect spatial patterns like edges, textures, and shapes in images, building hierarchical feature representations."
        },
        {
            "id": 347,
            "type": "multiple_choice",
            "category": "convolutional_networks",
            "difficulty": "intermediate",
            "question": "What is parameter sharing in convolutional neural networks?",
            "options": [
                "Using the same weights across different spatial locations",
                "Sharing weights between different models",
                "Using the same bias for all neurons",
                "Reusing the same dataset multiple times"
            ],
            "correct_answer": 0,
            "explanation": "Parameter sharing means the same filter weights are applied across all spatial locations in the input, dramatically reducing the number of parameters compared to fully connected layers."
        },
        {
            "id": 348,
            "type": "multiple_choice",
            "category": "pooling_layers",
            "difficulty": "intermediate",
            "question": "What is the purpose of pooling layers in CNNs?",
            "options": [
                "To increase the spatial dimensions",
                "To reduce spatial size while retaining important features",
                "To add more parameters to the model",
                "To replace convolutional layers"
            ],
            "correct_answer": 1,
            "explanation": "Pooling layers (like max pooling) reduce spatial dimensions, making the network more computationally efficient and providing translation invariance to small shifts."
        },
        {
            "id": 349,
            "type": "multiple_choice",
            "category": "convolutional_networks",
            "difficulty": "advanced",
            "question": "What is the receptive field in convolutional neural networks?",
            "options": [
                "The area of input that affects a particular neuron",
                "The learning rate for convolutional layers",
                "The number of filters in a layer",
                "The padding size around the input"
            ],
            "correct_answer": 0,
            "explanation": "The receptive field is the region in the input space that a particular CNN's feature is looking at, which grows larger in deeper layers through successive convolutions."
        },
        {
            "id": 350,
            "type": "multiple_choice",
            "category": "padding_stride",
            "difficulty": "intermediate",
            "question": "What is the purpose of padding in convolutional layers?",
            "options": [
                "To reduce the output size",
                "To preserve spatial dimensions of the input",
                "To increase the number of parameters",
                "To speed up computation"
            ],
            "correct_answer": 1,
            "explanation": "Padding adds zeros around the input border, allowing the convolutional layer to maintain the spatial dimensions of the input rather than reducing them."
        },
        {
            "id": 351,
            "type": "multiple_choice",
            "category": "padding_stride",
            "difficulty": "intermediate",
            "question": "How does stride affect the output size in convolutional layers?",
            "options": [
                "Larger stride increases output size",
                "Stride has no effect on output size",
                "Larger stride decreases output size",
                "Stride only affects training speed"
            ],
            "correct_answer": 2,
            "explanation": "Larger stride values cause the filter to skip more positions, resulting in smaller output dimensions and more aggressive downsampling."
        },
        {
            "id": 352,
            "type": "calculation",
            "category": "convolutional_networks",
            "difficulty": "advanced",
            "question": "Given an input of size 32x32, filter size 3x3, padding 'same', and stride 1, what is the output size?",
            "options": [
                "30x30",
                "32x32",
                "34x34",
                "28x28"
            ],
            "correct_answer": 1,
            "explanation": "With 'same' padding and stride 1, the convolutional layer maintains the same spatial dimensions as the input (32x32)."
        },
        {
            "id": 353,
            "type": "multiple_choice",
            "category": "feature_maps",
            "difficulty": "intermediate",
            "question": "What do feature maps represent in convolutional neural networks?",
            "options": [
                "The input images to the network",
                "The learned patterns detected by filters at different locations",
                "The training loss over time",
                "The validation accuracy scores"
            ],
            "correct_answer": 1,
            "explanation": "Feature maps are the outputs of convolutional layers, showing where specific patterns (detected by filters) appear in the input image."
        },
        {
            "id": 354,
            "type": "multiple_choice",
            "category": "transfer_learning",
            "difficulty": "advanced",
            "question": "What is the main advantage of transfer learning?",
            "options": [
                "Eliminates the need for any training",
                "Leverages pre-trained models for new tasks with limited data",
                "Makes models smaller in size",
                "Increases model interpretability"
            ],
            "correct_answer": 1,
            "explanation": "Transfer learning uses features learned from large datasets (like ImageNet) on new tasks with limited data, significantly reducing training time and data requirements."
        },
        {
            "id": 355,
            "type": "multiple_choice",
            "category": "data_augmentation",
            "difficulty": "intermediate",
            "question": "How does data augmentation help prevent overfitting?",
            "options": [
                "By reducing the model size",
                "By artificially increasing training data diversity",
                "By removing noisy samples from the dataset",
                "By slowing down the training process"
            ],
            "correct_answer": 1,
            "explanation": "Data augmentation creates modified versions of training images (rotations, flips, zooms, etc.), effectively increasing dataset size and diversity to improve generalization."
        },
        {
            "id": 356,
            "type": "multiple_choice",
            "category": "rnn_architecture",
            "difficulty": "intermediate",
            "question": "What makes RNNs suitable for sequential data processing?",
            "options": [
                "They have larger parameter counts than CNNs",
                "They maintain internal state/memory of previous inputs",
                "They process all sequence elements simultaneously",
                "They require less training data"
            ],
            "correct_answer": 1,
            "explanation": "RNNs have recurrent connections that allow them to maintain an internal state representing information from previous time steps, making them ideal for sequences where context matters."
        },
        {
            "id": 357,
            "type": "multiple_choice",
            "category": "rnn_limitations",
            "difficulty": "advanced",
            "question": "What is the fundamental limitation of basic RNNs that LSTMs address?",
            "options": [
                "They are too slow for real-time applications",
                "They cannot handle variable-length sequences",
                "They struggle with long-term dependencies due to vanishing gradients",
                "They require too much memory"
            ],
            "correct_answer": 2,
            "explanation": "Basic RNNs suffer from vanishing gradient problems that make it difficult to learn long-range dependencies in sequences, which LSTMs solve through gating mechanisms."
        },
        {
            "id": 358,
            "type": "multiple_choice",
            "category": "lstm_gates",
            "difficulty": "advanced",
            "question": "What are the three gates in an LSTM cell?",
            "options": [
                "Input, Output, and Memory gates",
                "Forget, Remember, and Output gates",
                "Input, Forget, and Output gates",
                "Read, Write, and Update gates"
            ],
            "correct_answer": 2,
            "explanation": "LSTMs contain three gates: Input gate (what new information to store), Forget gate (what information to discard), and Output gate (what information to output)."
        },
        {
            "id": 359,
            "type": "multiple_choice",
            "category": "gru_architecture",
            "difficulty": "advanced",
            "question": "How does GRU (Gated Recurrent Unit) differ from LSTM?",
            "options": [
                "GRU has more parameters than LSTM",
                "GRU combines forget and input gates into a single update gate",
                "GRU doesn't use any gating mechanisms",
                "GRU cannot handle long sequences"
            ],
            "correct_answer": 1,
            "explanation": "GRU simplifies the LSTM architecture by combining the input and forget gates into a single update gate and merging the cell state with hidden state, resulting in fewer parameters."
        },
        {
            "id": 360,
            "type": "multiple_choice",
            "category": "bidirectional_rnn",
            "difficulty": "advanced",
            "question": "What is the advantage of bidirectional RNNs?",
            "options": [
                "They train twice as fast as regular RNNs",
                "They process sequences in both forward and backward directions",
                "They require half the parameters of regular RNNs",
                "They eliminate the need for activation functions"
            ],
            "correct_answer": 1,
            "explanation": "Bidirectional RNNs process sequences in both forward and backward directions, allowing them to capture context from both past and future elements simultaneously."
        },
        {
            "id": 361,
            "type": "multiple_choice",
            "category": "attention_mechanism",
            "difficulty": "advanced",
            "question": "What problem does the attention mechanism solve in sequence models?",
            "options": [
                "Slow training speed",
                "Difficulty in focusing on relevant parts of long sequences",
                "High memory consumption",
                "Lack of non-linearity"
            ],
            "correct_answer": 1,
            "explanation": "Attention mechanisms allow models to dynamically focus on different parts of the input sequence when producing each output, improving performance on long sequences and complex tasks."
        },
        {
            "id": 362,
            "type": "multiple_choice",
            "category": "transformer_architecture",
            "difficulty": "advanced",
            "question": "What is the key innovation of transformer models over RNNs?",
            "options": [
                "They use convolutional layers instead of recurrent ones",
                "They rely entirely on self-attention mechanisms without recurrence",
                "They eliminate the need for backpropagation",
                "They use smaller embedding dimensions"
            ],
            "correct_answer": 1,
            "explanation": "Transformers replace recurrence with self-attention mechanisms, allowing parallel processing of entire sequences and better handling of long-range dependencies."
        },
        {
            "id": 363,
            "type": "multiple_choice",
            "category": "embedding_layers",
            "difficulty": "intermediate",
            "question": "What is the purpose of embedding layers in neural networks for NLP?",
            "options": [
                "To convert text to images",
                "To represent categorical data as dense vectors",
                "To reduce model size",
                "To increase training speed"
            ],
            "correct_answer": 1,
            "explanation": "Embedding layers learn dense vector representations of categorical data (like words) where similar items have similar vector representations, capturing semantic relationships."
        },
        {
            "id": 364,
            "type": "multiple_choice",
            "category": "word_embeddings",
            "difficulty": "intermediate",
            "question": "What do word embeddings like Word2Vec and GloVe capture?",
            "options": [
                "Only word frequency information",
                "Syntactic and semantic relationships between words",
                "The visual appearance of words",
                "The pronunciation of words"
            ],
            "correct_answer": 1,
            "explanation": "Word embeddings capture syntactic and semantic relationships, so words with similar meanings or usage patterns have similar vector representations in the embedding space."
        },
        {
            "id": 365,
            "type": "multiple_choice",
            "category": "autoencoders",
            "difficulty": "advanced",
            "question": "What is the typical structure of an autoencoder?",
            "options": [
                "Two separate networks trained independently",
                "An encoder that compresses input and a decoder that reconstructs it",
                "A single layer with recurrent connections",
                "Multiple convolutional layers without pooling"
            ],
            "correct_answer": 1,
            "explanation": "Autoencoders consist of an encoder network that compresses input into a latent representation and a decoder network that reconstructs the input from this representation."
        },
        {
            "id": 366,
            "type": "multiple_choice",
            "category": "autoencoder_applications",
            "difficulty": "intermediate",
            "question": "Which task is NOT typically suited for autoencoders?",
            "options": [
                "Dimensionality reduction",
                "Anomaly detection",
                "Image denoising",
                "Multi-class classification with 1000 classes"
            ],
            "correct_answer": 3,
            "explanation": "While autoencoders excel at unsupervised tasks like dimensionality reduction, denoising, and anomaly detection, they are not directly designed for supervised multi-class classification with many classes."
        },
        {
            "id": 367,
            "type": "multiple_choice",
            "category": "variational_autoencoders",
            "difficulty": "advanced",
            "question": "How do Variational Autoencoders (VAEs) differ from standard autoencoders?",
            "options": [
                "VAEs learn deterministic encodings",
                "VAEs learn probabilistic latent representations",
                "VAEs have more encoder layers",
                "VAEs don't use decoder networks"
            ],
            "correct_answer": 1,
            "explanation": "VAEs learn probabilistic latent representations by modeling the latent space as a probability distribution, enabling generative capabilities unlike deterministic standard autoencoders."
        },
        {
            "id": 368,
            "type": "multiple_choice",
            "category": "gan_architecture",
            "difficulty": "advanced",
            "question": "What are the two main components of a Generative Adversarial Network (GAN)?",
            "options": [
                "Encoder and Decoder",
                "Generator and Discriminator",
                "Teacher and Student",
                "Producer and Consumer"
            ],
            "correct_answer": 1,
            "explanation": "GANs consist of a Generator that creates synthetic data and a Discriminator that distinguishes between real and generated data, trained adversarially against each other."
        },
        {
            "id": 369,
            "type": "multiple_choice",
            "category": "gan_training",
            "difficulty": "advanced",
            "question": "What is the training objective in GANs?",
            "options": [
                "Both networks cooperate to minimize the same loss",
                "Generator tries to fool Discriminator, Discriminator tries to detect fakes",
                "Only the Generator is trained, Discriminator is fixed",
                "Networks take turns being frozen during training"
            ],
            "correct_answer": 1,
            "explanation": "In GAN training, the Generator aims to produce realistic data to fool the Discriminator, while the Discriminator learns to better distinguish real from fake data - creating an adversarial training dynamic."
        },
        {
            "id": 370,
            "type": "multiple_choice",
            "category": "reinforcement_learning",
            "difficulty": "advanced",
            "question": "How does deep reinforcement learning differ from supervised learning?",
            "options": [
                "It uses deeper neural networks",
                "It learns from rewards rather than labeled examples",
                "It requires more training data",
                "It only works for image data"
            ],
            "correct_answer": 1,
            "explanation": "Deep reinforcement learning uses neural networks to learn policies that maximize cumulative rewards through interaction with an environment, unlike supervised learning which uses labeled examples."
        },
        {
            "id": 371,
            "type": "multiple_choice",
            "category": "ethical_ai",
            "difficulty": "intermediate",
            "question": "What is a major ethical concern when using neural networks in criminal justice applications?",
            "options": [
                "They are too accurate",
                "They can perpetuate biases from historical data",
                "They require too much computational power",
                "They are too transparent in their decision-making"
            ],
            "correct_answer": 1,
            "explanation": "Neural networks trained on historical criminal justice data may learn and amplify existing biases, leading to unfair treatment of certain demographic groups."
        },
        {
            "id": 372,
            "type": "multiple_choice",
            "category": "model_interpretability",
            "difficulty": "intermediate",
            "question": "What is the 'black box' problem in neural networks?",
            "options": [
                "The difficulty in understanding how models arrive at decisions",
                "The use of dark color schemes in visualization tools",
                "The tendency to overfit on training data",
                "The requirement for specialized hardware"
            ],
            "correct_answer": 0,
            "explanation": "The 'black box' problem refers to the difficulty in interpreting and understanding the reasoning behind neural network predictions, which is crucial for applications requiring transparency."
        },
        {
            "id": 373,
            "type": "multiple_choice",
            "category": "hyperparameter_tuning",
            "difficulty": "intermediate",
            "question": "What is the purpose of hyperparameter tuning?",
            "options": [
                "To adjust the model architecture during training",
                "To find optimal settings that control the learning process",
                "To change the input data distribution",
                "To reduce the model size"
            ],
            "correct_answer": 1,
            "explanation": "Hyperparameter tuning involves finding the best settings for parameters that control the learning process (like learning rate, batch size) rather than the weights learned during training."
        },
        {
            "id": 374,
            "type": "multiple_choice",
            "category": "cross_validation",
            "difficulty": "intermediate",
            "question": "Why is k-fold cross-validation used?",
            "options": [
                "To reduce training time",
                "To get more reliable performance estimates using all data",
                "To increase model complexity",
                "To eliminate the need for a test set"
            ],
            "correct_answer": 1,
            "explanation": "K-fold cross-validation uses all data for both training and validation in different folds, providing more reliable performance estimates and better use of limited data."
        },
        {
            "id": 375,
            "type": "multiple_choice",
            "category": "learning_rate_scheduling",
            "difficulty": "advanced",
            "question": "What is the benefit of learning rate scheduling?",
            "options": [
                "It eliminates the need for gradient descent",
                "It allows larger steps initially and finer adjustments later",
                "It reduces the number of model parameters",
                "It automatically selects the best optimizer"
            ],
            "correct_answer": 1,
            "explanation": "Learning rate scheduling starts with higher learning rates for faster progress and gradually reduces them for finer convergence near the optimum."
        },
        {
            "id": 376,
            "type": "code_completion",
            "category": "tensorflow_basics",
            "difficulty": "intermediate",
            "question": "Complete the code to create a learning rate scheduler that reduces LR when validation loss plateaus:",
            "code_snippet": "reduce_lr = ______(monitor='val_loss', factor=0.5, patience=3)",
            "options": [
                "ReduceLROnPlateau",
                "LearningRateScheduler",
                "LRCallback",
                "AdjustLR"
            ],
            "correct_answer": 0,
            "explanation": "ReduceLROnPlateau is a Keras callback that reduces the learning rate when a monitored metric (like val_loss) stops improving."
        },
        {
            "id": 377,
            "type": "multiple_choice",
            "category": "model_ensembling",
            "difficulty": "advanced",
            "question": "What is the main advantage of model ensembling?",
            "options": [
                "Reduces training time",
                "Combines predictions from multiple models for better performance",
                "Makes models more interpretable",
                "Eliminates the need for validation data"
            ],
            "correct_answer": 1,
            "explanation": "Ensembling combines predictions from multiple models, often reducing variance and improving overall performance through diversity and collective decision-making."
        },
        {
            "id": 378,
            "type": "multiple_choice",
            "category": "transfer_learning_techniques",
            "difficulty": "intermediate",
            "question": "What is feature extraction in transfer learning?",
            "options": [
                "Using a pre-trained model as a fixed feature extractor",
                "Extracting features manually from images",
                "Training only the last layer of a model",
                "Removing features from the dataset"
            ],
            "correct_answer": 0,
            "explanation": "Feature extraction uses a pre-trained model with frozen weights as a fixed feature extractor, then trains a new classifier on top of these features."
        },
        {
            "id": 379,
            "type": "multiple_choice",
            "category": "transfer_learning_techniques",
            "difficulty": "intermediate",
            "question": "What is fine-tuning in transfer learning?",
            "options": [
                "Using only the pre-trained model's architecture",
                "Unfreezing and retraining some layers of a pre-trained model",
                "Making the model smaller",
                "Training with a very small learning rate"
            ],
            "correct_answer": 1,
            "explanation": "Fine-tuning involves unfreezing some layers of a pre-trained model and continuing training on the new dataset to adapt the learned features."
        },
        {
            "id": 380,
            "type": "multiple_choice",
            "category": "computer_vision",
            "difficulty": "intermediate",
            "question": "What is the purpose of data augmentation in computer vision?",
            "options": [
                "To reduce image quality for faster processing",
                "To artificially increase dataset size and diversity",
                "To convert color images to grayscale",
                "To eliminate the need for validation sets"
            ],
            "correct_answer": 1,
            "explanation": "Data augmentation creates modified versions of training images through transformations, effectively increasing dataset size and improving model generalization."
        },
        {
            "id": 381,
            "type": "multiple_choice",
            "category": "computer_vision",
            "difficulty": "intermediate",
            "question": "Which transformation is commonly used in image data augmentation?",
            "options": [
                "Random rotations and flips",
                "Changing image file formats",
                "Reducing image resolution",
                "Converting to black and white only"
            ],
            "correct_answer": 0,
            "explanation": "Random rotations, flips, zooms, and brightness adjustments are common augmentations that help models become invariant to these transformations."
        },
        {
            "id": 382,
            "type": "multiple_choice",
            "category": "nlp_preprocessing",
            "difficulty": "intermediate",
            "question": "What is tokenization in natural language processing?",
            "options": [
                "Converting words to numbers",
                "Splitting text into individual words or subwords",
                "Removing stop words from text",
                "Converting text to lowercase"
            ],
            "correct_answer": 1,
            "explanation": "Tokenization breaks text into individual tokens (words, subwords, or characters) that can be processed by neural networks."
        },
        {
            "id": 383,
            "type": "multiple_choice",
            "category": "nlp_preprocessing",
            "difficulty": "intermediate",
            "question": "What is the purpose of padding sequences in NLP?",
            "options": [
                "To make all sequences the same length for batch processing",
                "To add random noise to text data",
                "To encrypt sensitive information",
                "To reduce vocabulary size"
            ],
            "correct_answer": 0,
            "explanation": "Padding ensures all sequences in a batch have the same length by adding special tokens, which is necessary for efficient batch processing in neural networks."
        },
        {
            "id": 384,
            "type": "multiple_choice",
            "category": "sequence_models",
            "difficulty": "advanced",
            "question": "What is teacher forcing in sequence-to-sequence models?",
            "options": [
                "Using the true previous output as input during training",
                "Forcing the model to learn faster",
                "Using a teacher model to guide training",
                "Making the model output longer sequences"
            ],
            "correct_answer": 0,
            "explanation": "Teacher forcing uses the ground truth from previous time steps as input during training, which helps stabilize and accelerate training of RNN-based models."
        },
        {
            "id": 385,
            "type": "multiple_choice",
            "category": "model_deployment",
            "difficulty": "intermediate",
            "question": "What is model quantization?",
            "options": [
                "Reducing precision of model weights to decrease size and speed up inference",
                "Increasing model complexity",
                "Converting models to quantum computing format",
                "Counting the number of parameters in a model"
            ],
            "correct_answer": 0,
            "explanation": "Quantization reduces the precision of weights and activations (e.g., from 32-bit to 8-bit), significantly reducing model size and speeding up inference with minimal accuracy loss."
        },
        {
            "id": 386,
            "type": "multiple_choice",
            "category": "neural_network_math",
            "difficulty": "intermediate",
            "question": "What mathematical operation is at the core of a neuron's computation?",
            "options": [
                "Matrix multiplication and addition",
                "Trigonometric functions",
                "Logarithmic transformations",
                "Differential equations"
            ],
            "correct_answer": 0,
            "explanation": "Each neuron computes a weighted sum of inputs (matrix multiplication) plus a bias (addition), then applies an activation function to produce the output."
        },
        {
            "id": 387,
            "type": "multiple_choice",
            "category": "neural_network_math",
            "difficulty": "advanced",
            "question": "Why are derivatives important in neural network training?",
            "options": [
                "They determine the model architecture",
                "They indicate the direction and magnitude for weight updates",
                "They calculate the model's accuracy",
                "They normalize the input data"
            ],
            "correct_answer": 1,
            "explanation": "Derivatives (gradients) indicate how the loss changes with respect to each weight, showing the direction and magnitude needed for weight updates during backpropagation."
        },
        {
            "id": 388,
            "type": "multiple_choice",
            "category": "optimization_math",
            "difficulty": "advanced",
            "question": "What is the purpose of the chain rule in backpropagation?",
            "options": [
                "To initialize network weights",
                "To compute gradients through composite functions",
                "To determine the learning rate",
                "To calculate the loss function"
            ],
            "correct_answer": 1,
            "explanation": "The chain rule allows computation of gradients through multiple layers by breaking down the derivative of composite functions into simpler multiplicative components."
        },
        {
            "id": 389,
            "type": "multiple_choice",
            "category": "probability_ml",
            "difficulty": "intermediate",
            "question": "How are probabilities used in classification neural networks?",
            "options": [
                "They determine the number of layers",
                "They represent confidence scores for each class",
                "They calculate training time",
                "They set the learning rate"
            ],
            "correct_answer": 1,
            "explanation": "Output probabilities represent the model's confidence that an input belongs to each class, with the highest probability indicating the predicted class."
        },
        {
            "id": 390,
            "type": "multiple_choice",
            "category": "loss_functions_math",
            "difficulty": "advanced",
            "question": "What does cross-entropy loss measure?",
            "options": [
                "The Euclidean distance between predictions and targets",
                "The difference between two probability distributions",
                "The absolute error of predictions",
                "The variance of the predictions"
            ],
            "correct_answer": 1,
            "explanation": "Cross-entropy measures the difference between two probability distributions - the true distribution (labels) and the predicted distribution."
        },
        {
            "id": 391,
            "type": "multiple_choice",
            "category": "convolution_math",
            "difficulty": "intermediate",
            "question": "What mathematical operation does a convolutional layer perform?",
            "options": [
                "Matrix multiplication",
                "Cross-correlation or convolution",
                "Element-wise addition",
                "Fourier transform"
            ],
            "correct_answer": 1,
            "explanation": "Convolutional layers perform cross-correlation (sliding dot product) between input patches and learned filters, which is mathematically similar to convolution."
        },
        {
            "id": 392,
            "type": "calculation",
            "category": "convolution_math",
            "difficulty": "advanced",
            "question": "Given input size 28x28, filter size 3x3, padding 0, stride 1, what is the output size?",
            "options": [
                "25x25",
                "26x26",
                "27x27",
                "28x28"
            ],
            "correct_answer": 1,
            "explanation": "Output size = floor((input_size - filter_size + 2*padding)/stride) + 1 = floor((28-3+0)/1) + 1 = 25 + 1 = 26"
        },
        {
            "id": 393,
            "type": "multiple_choice",
            "category": "pooling_math",
            "difficulty": "intermediate",
            "question": "What operation does max pooling perform?",
            "options": [
                "Takes the average of values in a window",
                "Takes the maximum value in a window",
                "Multiplies values in a window",
                "Sums values in a window"
            ],
            "correct_answer": 1,
            "explanation": "Max pooling slides a window over the input and outputs the maximum value within each window, providing translation invariance and reducing spatial dimensions."
        },
        {
            "id": 394,
            "type": "multiple_choice",
            "category": "activation_math",
            "difficulty": "intermediate",
            "question": "What is the derivative of the ReLU activation function?",
            "options": [
                "1 for positive inputs, 0 for negative inputs",
                "Always 1",
                "S-shaped curve",
                "Linear function"
            ],
            "correct_answer": 0,
            "explanation": "ReLU derivative is 1 for inputs > 0 and 0 for inputs â¤ 0, which is computationally efficient but can cause dying ReLU problems."
        },
        {
            "id": 395,
            "type": "multiple_choice",
            "category": "softmax_math",
            "difficulty": "advanced",
            "question": "What mathematical property makes softmax suitable for classification?",
            "options": [
                "It outputs values that sum to 1",
                "It always outputs the same value",
                "It increases the output range",
                "It reduces computational complexity"
            ],
            "correct_answer": 0,
            "explanation": "Softmax outputs a probability distribution where all values are between 0-1 and sum to 1, making them interpretable as class probabilities."
        },
        {
            "id": 396,
            "type": "multiple_choice",
            "category": "gradient_descent_math",
            "difficulty": "intermediate",
            "question": "What is the weight update formula in gradient descent?",
            "options": [
                "w_new = w_old - learning_rate * gradient",
                "w_new = w_old + learning_rate * gradient",
                "w_new = gradient * learning_rate",
                "w_new = w_old * gradient"
            ],
            "correct_answer": 0,
            "explanation": "Weights are updated by subtracting the learning_rate multiplied by the gradient, moving in the direction that decreases the loss function."
        },
        {
            "id": 397,
            "type": "multiple_choice",
            "category": "momentum_math",
            "difficulty": "advanced",
            "question": "How does momentum improve gradient descent?",
            "options": [
                "It eliminates the need for learning rates",
                "It accumulates past gradients to smooth updates",
                "It reduces the number of parameters",
                "It increases the learning rate over time"
            ],
            "correct_answer": 1,
            "explanation": "Momentum accumulates a moving average of past gradients, helping to smooth out oscillations and accelerate convergence in relevant directions."
        },
        {
            "id": 398,
            "type": "multiple_choice",
            "category": "batch_norm_math",
            "difficulty": "advanced",
            "question": "What does batch normalization compute for each feature?",
            "options": [
                "Mean and standard deviation across the batch",
                "Maximum and minimum values",
                "Median and mode",
                "Variance and covariance"
            ],
            "correct_answer": 0,
            "explanation": "Batch normalization computes the mean and standard deviation of each feature across the current mini-batch, then normalizes and scales the features."
        },
        {
            "id": 399,
            "type": "multiple_choice",
            "category": "attention_math",
            "difficulty": "advanced",
            "question": "What is the attention mechanism mathematically?",
            "options": [
                "A weighted sum of values based on relevance scores",
                "A matrix multiplication operation",
                "A convolution operation",
                "A pooling operation"
            ],
            "correct_answer": 0,
            "explanation": "Attention computes a weighted sum of values, where weights (attention scores) represent the relevance of each value to the current context."
        },
        {
            "id": 400,
            "type": "multiple_choice",
            "category": "evaluation_metrics",
            "difficulty": "intermediate",
            "question": "What does precision measure in classification?",
            "options": [
                "The proportion of true positives among all positive predictions",
                "The proportion of true positives among all actual positives",
                "The overall correctness of predictions",
                "The balance between different classes"
            ],
            "correct_answer": 0,
            "explanation": "Precision = TP / (TP + FP) - it measures how many of the predicted positive cases are actually positive, important when false positives are costly."
        },
        {
            "id": 401,
            "type": "multiple_choice",
            "category": "evaluation_metrics",
            "difficulty": "intermediate",
            "question": "What does recall measure in classification?",
            "options": [
                "The proportion of true positives among all positive predictions",
                "The proportion of true positives among all actual positives",
                "The overall accuracy of the model",
                "The balance between precision and specificity"
            ],
            "correct_answer": 1,
            "explanation": "Recall = TP / (TP + FN) - it measures how many of the actual positive cases were correctly identified, important when false negatives are costly."
        },
        {
            "id": 402,
            "type": "multiple_choice",
            "category": "evaluation_metrics",
            "difficulty": "intermediate",
            "question": "What is the F1-score?",
            "options": [
                "The average of precision and recall",
                "The harmonic mean of precision and recall",
                "The product of precision and recall",
                "The difference between precision and recall"
            ],
            "correct_answer": 1,
            "explanation": "F1-score is the harmonic mean of precision and recall, providing a single metric that balances both concerns: F1 = 2 * (precision * recall) / (precision + recall)."
        },
        {
            "id": 403,
            "type": "multiple_choice",
            "category": "confusion_matrix",
            "difficulty": "intermediate",
            "question": "What does a confusion matrix show?",
            "options": [
                "The training loss over time",
                "The distribution of predictions vs actual labels",
                "The model architecture",
                "The gradient values during backpropagation"
            ],
            "correct_answer": 1,
            "explanation": "A confusion matrix displays the counts of true positives, false positives, true negatives, and false negatives, providing detailed insight into model performance across classes."
        },
        {
            "id": 404,
            "type": "multiple_choice",
            "category": "roc_auc",
            "difficulty": "advanced",
            "question": "What does AUC-ROC measure?",
            "options": [
                "The model's overall accuracy",
                "The model's ability to distinguish between classes across all thresholds",
                "The training speed of the model",
                "The number of parameters in the model"
            ],
            "correct_answer": 1,
            "explanation": "AUC-ROC (Area Under the Receiver Operating Characteristic curve) measures the model's ability to distinguish between positive and negative classes across all possible classification thresholds."
        },
        {
            "id": 405,
            "type": "multiple_choice",
            "category": "feature_importance",
            "difficulty": "intermediate",
            "question": "What is feature importance in neural networks?",
            "options": [
                "The number of features in the dataset",
                "How much each feature contributes to predictions",
                "The size of feature vectors",
                "The correlation between features"
            ],
            "correct_answer": 1,
            "explanation": "Feature importance measures how much each input feature contributes to the model's predictions, though this can be challenging to interpret in deep neural networks due to their complex interactions."
        },
        {
            "id": 406,
            "type": "multiple_choice",
            "category": "model_debugging",
            "difficulty": "advanced",
            "question": "What does it indicate if training loss decreases but validation loss increases?",
            "options": [
                "The model is underfitting",
                "The model is overfitting",
                "The learning rate is too low",
                "The batch size is too small"
            ],
            "correct_answer": 1,
            "explanation": "When training loss decreases but validation loss increases, it typically indicates overfitting - the model is memorizing training data rather than learning general patterns."
        },
        {
            "id": 407,
            "type": "multiple_choice",
            "category": "model_debugging",
            "difficulty": "intermediate",
            "question": "What might cause exploding gradients?",
            "options": [
                "Learning rate too small",
                "Weights initialized with very small values",
                "Deep networks with large weight updates",
                "Using ReLU activation functions"
            ],
            "correct_answer": 2,
            "explanation": "Exploding gradients occur in deep networks when large weight updates cause gradients to grow exponentially through backpropagation, often due to high learning rates or poor weight initialization."
        },
        {
            "id": 408,
            "type": "multiple_choice",
            "category": "hardware_acceleration",
            "difficulty": "intermediate",
            "question": "Why are GPUs preferred for neural network training?",
            "options": [
                "They have higher clock speeds than CPUs",
                "They are better at parallel matrix operations",
                "They consume less power",
                "They have more cache memory"
            ],
            "correct_answer": 1,
            "explanation": "GPUs excel at parallel processing of matrix operations, which are fundamental to neural network computations, allowing much faster training than CPUs."
        },
        {
            "id": 409,
            "type": "multiple_choice",
            "category": "distributed_training",
            "difficulty": "advanced",
            "question": "What is data parallelism in distributed training?",
            "options": [
                "Splitting the model across multiple devices",
                "Processing different data batches on different devices",
                "Using different models for different data types",
                "Storing data in distributed file systems"
            ],
            "correct_answer": 1,
            "explanation": "Data parallelism involves replicating the model across multiple devices and processing different batches of data on each device, then synchronizing gradients."
        },
        {
            "id": 410,
            "type": "multiple_choice",
            "category": "model_compression",
            "difficulty": "advanced",
            "question": "What is knowledge distillation?",
            "options": [
                "Compressing model weights",
                "Training a small model to mimic a large model's behavior",
                "Removing unnecessary layers from a model",
                "Converting models to lower precision"
            ],
            "correct_answer": 1,
            "explanation": "Knowledge distillation trains a smaller student model to reproduce the outputs of a larger teacher model, preserving performance while reducing model size and computational requirements."
        },
        {
            "id": 411,
            "type": "multiple_choice",
            "category": "pruning",
            "difficulty": "advanced",
            "question": "What is neural network pruning?",
            "options": [
                "Removing training data samples",
                "Eliminating less important weights or neurons",
                "Reducing the number of epochs",
                "Decreasing the learning rate gradually"
            ],
            "correct_answer": 1,
            "explanation": "Pruning removes weights or neurons that contribute little to the model's output, creating sparser networks that are smaller and faster with minimal accuracy loss."
        },
        {
            "id": 412,
            "type": "multiple_choice",
            "category": "production_monitoring",
            "difficulty": "intermediate",
            "question": "What is model drift in production systems?",
            "options": [
                "The model becoming slower over time",
                "The model's performance degrading as data distributions change",
                "The model's weights changing during inference",
                "The model consuming more memory"
            ],
            "correct_answer": 1,
            "explanation": "Model drift occurs when the statistical properties of real-world data change over time, causing the model's performance to degrade as it encounters data different from what it was trained on."
        },
        {
            "id": 413,
            "type": "multiple_choice",
            "category": "mlops",
            "difficulty": "intermediate",
            "question": "What is the purpose of model versioning?",
            "options": [
                "To track different iterations of models and their performance",
                "To make models compatible with different frameworks",
                "To reduce model file sizes",
                "To speed up model training"
            ],
            "correct_answer": 0,
            "explanation": "Model versioning tracks different model iterations, their hyperparameters, training data, and performance metrics, enabling reproducibility and easy rollback if needed."
        },
        {
            "id": 414,
            "type": "multiple_choice",
            "category": "experiment_tracking",
            "difficulty": "intermediate",
            "question": "What should be tracked in machine learning experiments?",
            "options": [
                "Only the final model accuracy",
                "Hyperparameters, metrics, code versions, and data versions",
                "Only the training time and model size",
                "Only the loss values"
            ],
            "correct_answer": 1,
            "explanation": "Comprehensive experiment tracking includes hyperparameters, performance metrics, code versions, data versions, and environmental details to ensure reproducibility and facilitate comparison."
        },
        {
            "id": 415,
            "type": "multiple_choice",
            "category": "ai_ethics",
            "difficulty": "intermediate",
            "question": "What is fairness in AI systems?",
            "options": [
                "Equal performance across all demographic groups",
                "The fastest possible inference time",
                "The smallest model size",
                "The highest possible accuracy"
            ],
            "correct_answer": 0,
            "explanation": "Fairness in AI involves ensuring models perform equitably across different demographic groups and don't perpetuate or amplify existing biases."
        },
        {
            "id": 416,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import the Sequential model from Keras:",
            "code_snippet": "from keras.models import ______",
            "options": [
                "Sequential",
                "Model",
                "Network",
                "SequentialModel"
            ],
            "correct_answer": 0,
            "explanation": "Sequential is the class used for creating linear stacks of layers in Keras"
        },
        {
            "id": 417,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to add an Input layer to a Sequential model:",
            "code_snippet": "model.add(Input(shape=(______,)))",
            "options": [
                "X_train.shape[1]",
                "X_train.shape[0]",
                "X_train.columns",
                "X_train.size"
            ],
            "correct_answer": 0,
            "explanation": "X_train.shape[1] gives the number of features which defines the input dimension"
        },
        {
            "id": 418,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to add a Dense layer with 64 neurons and ReLU activation:",
            "code_snippet": "model.add(Dense(64, activation='______'))",
            "options": [
                "relu",
                "sigmoid",
                "tanh",
                "linear"
            ],
            "correct_answer": 0,
            "explanation": "ReLU (rectified linear unit) is commonly used in hidden layers for its effectiveness"
        },
        {
            "id": 419,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to compile a model with Mean Squared Error loss:",
            "code_snippet": "model.compile(optimizer='adam', loss=______())",
            "options": [
                "MeanSquaredError",
                "MSE",
                "mse",
                "MeanSquare"
            ],
            "correct_answer": 0,
            "explanation": "MeanSquaredError is the correct class name for MSE loss in Keras"
        },
        {
            "id": 420,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to fit a model for 10 epochs:",
            "code_snippet": "model.fit(X_train, y_train, epochs=______)",
            "options": [
                "10",
                "5",
                "20",
                "100"
            ],
            "correct_answer": 0,
            "explanation": "The epochs parameter specifies how many times the model will iterate through the entire dataset"
        },
        {
            "id": 421,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "Which component is used to introduce non-linearity in neural networks?",
            "options": [
                "Weights",
                "Bias",
                "Activation Function",
                "Epochs"
            ],
            "correct_answer": 2,
            "explanation": "Activation functions like ReLU, sigmoid, and tanh introduce non-linearity, allowing neural networks to learn complex patterns"
        },
        {
            "id": 422,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "What is the purpose of the final Dense layer with 1 neuron in regression problems?",
            "options": [
                "To output class probabilities",
                "To output a single continuous value",
                "To add non-linearity",
                "To reduce overfitting"
            ],
            "correct_answer": 1,
            "explanation": "In regression tasks, the output layer typically has 1 neuron that predicts a continuous value without activation function"
        },
        {
            "id": 423,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Which activation function is most appropriate for the output layer in binary classification?",
            "options": [
                "Softmax",
                "Sigmoid",
                "ReLU",
                "Tanh"
            ],
            "correct_answer": 1,
            "explanation": "Sigmoid outputs values between 0-1, making it ideal for binary classification probability outputs"
        },
        {
            "id": 424,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What does batch_size=16 mean in model training?",
            "options": [
                "The model trains on 16 samples before updating weights",
                "The model trains for 16 epochs",
                "The model has 16 hidden layers",
                "The learning rate is 16"
            ],
            "correct_answer": 0,
            "explanation": "Batch size determines how many samples are processed before the model's internal parameters are updated"
        },
        {
            "id": 425,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to add validation data during training:",
            "code_snippet": "history = model.fit(X_train, y_train, validation_data=(______))",
            "options": [
                "X_test, y_test",
                "X_val, y_val",
                "X_train, y_train",
                "X_test, y_train"
            ],
            "correct_answer": 0,
            "explanation": "validation_data should contain the test features and labels to monitor performance on unseen data"
        },
        {
            "id": 426,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to compile a model with additional metrics:",
            "code_snippet": "model.compile(optimizer='adam', loss=MeanSquaredError(), metrics=['______'])",
            "options": [
                "mae",
                "mse",
                "accuracy",
                "precision"
            ],
            "correct_answer": 0,
            "explanation": "MAE (Mean Absolute Error) is a common additional metric for regression problems"
        },
        {
            "id": 427,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the main advantage of using hidden layers in neural networks?",
            "options": [
                "They reduce training time",
                "They allow the network to learn more complex patterns",
                "They prevent overfitting",
                "They increase interpretability"
            ],
            "correct_answer": 1,
            "explanation": "Hidden layers with activation functions enable neural networks to learn non-linear relationships and complex patterns in data"
        },
        {
            "id": 428,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Which optimizer is commonly used as a default in Keras?",
            "options": [
                "SGD",
                "Adam",
                "RMSprop",
                "Adagrad"
            ],
            "correct_answer": 1,
            "explanation": "Adam optimizer is widely used as a default because it combines the advantages of RMSprop and momentum"
        },
        {
            "id": 429,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What happens when a model's loss function flattens out early during training?",
            "options": [
                "The model has converged to optimal performance",
                "The model may be stuck in a local minimum",
                "The model is overfitting",
                "The model needs more data"
            ],
            "correct_answer": 1,
            "explanation": "A flattening loss curve suggests the model may be stuck and not continuing to learn effectively"
        },
        {
            "id": 430,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "Why are CNNs preferred over MLPs for image classification?",
            "options": [
                "CNNs are faster to train",
                "CNNs preserve spatial relationships in images",
                "CNNs have fewer parameters",
                "CNNs don't require preprocessing"
            ],
            "correct_answer": 1,
            "explanation": "CNNs use convolutional layers that preserve spatial relationships and are better at detecting local patterns like edges and textures in images"
        },
        {
            "id": 431,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to load the diabetes dataset from scikit-learn:",
            "code_snippet": "diabetes = ______()",
            "options": [
                "load_diabetes",
                "load_dataset",
                "datasets.load_diabetes",
                "get_diabetes"
            ],
            "correct_answer": 0,
            "explanation": "load_diabetes() is the function to load the diabetes dataset from sklearn.datasets"
        },
        {
            "id": 432,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to split data into training and test sets:",
            "code_snippet": "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, ______=1)",
            "options": [
                "random_state",
                "shuffle",
                "seed",
                "random"
            ],
            "correct_answer": 0,
            "explanation": "random_state ensures reproducible splits by controlling the randomness of the shuffle"
        },
        {
            "id": 433,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "What does the Sequential model in Keras represent?",
            "options": [
                "A model with parallel layers",
                "A linear stack of layers",
                "A recurrent neural network",
                "A convolutional network"
            ],
            "correct_answer": 1,
            "explanation": "The Sequential model is a linear stack of layers where each layer has exactly one input and one output tensor"
        },
        {
            "id": 434,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Which activation function outputs values between -1 and 1?",
            "options": [
                "ReLU",
                "Sigmoid",
                "Tanh",
                "Softmax"
            ],
            "correct_answer": 2,
            "explanation": "Tanh (hyperbolic tangent) activation function outputs values in the range [-1, 1]"
        },
        {
            "id": 435,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with tanh activation in hidden layers:",
            "code_snippet": "model.add(Dense(10, activation='______'))",
            "options": [
                "tanh",
                "relu",
                "sigmoid",
                "linear"
            ],
            "correct_answer": 0,
            "explanation": "tanh activation can be used in hidden layers and outputs values between -1 and 1"
        },
        {
            "id": 436,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the purpose of the Adam optimizer?",
            "options": [
                "To initialize weights randomly",
                "To adjust learning rates for each parameter",
                "To add regularization",
                "To select the best activation function"
            ],
            "correct_answer": 1,
            "explanation": "Adam optimizer adapts the learning rate for each parameter individually, combining advantages of AdaGrad and RMSProp"
        },
        {
            "id": 437,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import Dense layers from Keras:",
            "code_snippet": "from keras.layers import ______",
            "options": [
                "Dense",
                "Layer",
                "NeuralLayer",
                "FullyConnected"
            ],
            "correct_answer": 0,
            "explanation": "Dense is the class for fully connected layers in Keras"
        },
        {
            "id": 438,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Why is Mean Squared Error commonly used for regression problems?",
            "options": [
                "It works best for classification",
                "It penalizes large errors more heavily",
                "It's the only loss function available",
                "It prevents overfitting"
            ],
            "correct_answer": 1,
            "explanation": "MSE squares the errors, giving higher penalty to larger errors, which is suitable for regression tasks"
        },
        {
            "id": 439,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to use SGD optimizer instead of Adam:",
            "code_snippet": "model.compile(optimizer='______', loss=MeanSquaredError())",
            "options": [
                "sgd",
                "SGD",
                "gradient_descent",
                "sdg"
            ],
            "correct_answer": 0,
            "explanation": "'sgd' is the string identifier for Stochastic Gradient Descent optimizer in Keras"
        },
        {
            "id": 440,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What is the effect of increasing the number of epochs during training?",
            "options": [
                "The model trains faster",
                "The model sees the entire dataset more times",
                "The batch size increases",
                "The learning rate decreases"
            ],
            "correct_answer": 1,
            "explanation": "Each epoch represents one complete pass through the entire training dataset"
        },
        {
            "id": 441,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Which of these is NOT a typical activation function for hidden layers?",
            "options": [
                "ReLU",
                "Tanh",
                "Sigmoid",
                "Softmax"
            ],
            "correct_answer": 3,
            "explanation": "Softmax is typically used in the output layer for multi-class classification, not in hidden layers"
        },
        {
            "id": 442,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to extract features and target from diabetes dataset:",
            "code_snippet": "X, y = diabetes['______'], diabetes['target']",
            "options": [
                "data",
                "features",
                "X",
                "inputs"
            ],
            "correct_answer": 0,
            "explanation": "The diabetes dataset stores features in 'data' key and target values in 'target' key"
        },
        {
            "id": 443,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What is the main advantage of using a smaller batch size?",
            "options": [
                "Faster training per epoch",
                "More stable convergence",
                "More frequent weight updates",
                "Lower memory usage"
            ],
            "correct_answer": 2,
            "explanation": "Smaller batch sizes result in more frequent weight updates, which can help escape local minima"
        },
        {
            "id": 444,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "In the diabetes dataset, what does X_train.shape[1] represent?",
            "options": [
                "Number of training samples",
                "Number of features",
                "Number of test samples",
                "Number of target classes"
            ],
            "correct_answer": 1,
            "explanation": "X_train.shape[1] gives the number of columns/features in the training data"
        },
        {
            "id": 445,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with mixed activation functions:",
            "code_snippet": "model.add(Dense(8, activation='relu'))\nmodel.add(Dense(4, activation='______'))",
            "options": [
                "tanh",
                "softmax",
                "linear",
                "sigmoid"
            ],
            "correct_answer": 0,
            "explanation": "Using different activation functions like ReLU and tanh in different layers can help the model learn diverse patterns"
        },
        {
            "id": 446,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the primary purpose of the validation_data parameter in model.fit()?",
            "options": [
                "To provide additional training data",
                "To monitor model performance on unseen data during training",
                "To speed up the training process",
                "To reduce overfitting by adding noise"
            ],
            "correct_answer": 1,
            "explanation": "validation_data allows monitoring of model performance on test data during training to detect overfitting and determine when to stop training"
        },
        {
            "id": 447,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import MeanSquaredError loss from Keras:",
            "code_snippet": "from keras.losses import ______",
            "options": [
                "MeanSquaredError",
                "MSE",
                "mean_squared_error",
                "LossMSE"
            ],
            "correct_answer": 0,
            "explanation": "MeanSquaredError is the class name for MSE loss in Keras"
        },
        {
            "id": 448,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "Why might a model with sigmoid activation in hidden layers suffer from vanishing gradients?",
            "options": [
                "Sigmoid outputs are always positive",
                "Sigmoid gradients approach zero for large inputs",
                "Sigmoid requires more memory",
                "Sigmoid is too computationally expensive"
            ],
            "correct_answer": 1,
            "explanation": "Sigmoid activation saturates for large positive/negative inputs, causing gradients to approach zero and slowing down learning in deep networks"
        },
        {
            "id": 449,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to train a model with batch size 16:",
            "code_snippet": "model.fit(X_train, y_train, epochs=10, ______=16)",
            "options": [
                "batch_size",
                "batch",
                "samples_per_batch",
                "batch_num"
            ],
            "correct_answer": 0,
            "explanation": "batch_size parameter controls how many samples are processed before updating model weights"
        },
        {
            "id": 450,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the key difference between ReLU and Leaky ReLU activation functions?",
            "options": [
                "Leaky ReLU allows small negative outputs",
                "ReLU works only for classification",
                "Leaky ReLU is faster to compute",
                "ReLU has bounded outputs"
            ],
            "correct_answer": 0,
            "explanation": "Leaky ReLU allows a small, non-zero gradient when the input is negative, helping to prevent 'dying ReLU' problem"
        },
        {
            "id": 451,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create the final output layer for regression:",
            "code_snippet": "model.add(Dense(______))",
            "options": [
                "1",
                "2",
                "10",
                "0"
            ],
            "correct_answer": 0,
            "explanation": "Regression problems typically use 1 neuron in the output layer to predict a continuous value"
        },
        {
            "id": 452,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "How does increasing the number of neurons in a hidden layer affect the model?",
            "options": [
                "Increases model capacity and potential for overfitting",
                "Decreases training time",
                "Reduces model complexity",
                "Forces linear relationships"
            ],
            "correct_answer": 0,
            "explanation": "More neurons increase the model's capacity to learn complex patterns but also increase the risk of overfitting if not properly regularized"
        },
        {
            "id": 453,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to use sigmoid activation in a hidden layer:",
            "code_snippet": "model.add(Dense(5, activation='______'))",
            "options": [
                "sigmoid",
                "relu",
                "tanh",
                "softmax"
            ],
            "correct_answer": 0,
            "explanation": "Sigmoid activation can be used in hidden layers, though ReLU is more common in modern architectures"
        },
        {
            "id": 454,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the role of the optimizer in neural network training?",
            "options": [
                "To initialize the model weights",
                "To update model parameters to minimize loss",
                "To select the best activation functions",
                "To determine the number of layers"
            ],
            "correct_answer": 1,
            "explanation": "Optimizers adjust the model's weights and biases during training to minimize the loss function through gradient-based optimization"
        },
        {
            "id": 455,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "Which of these is a key property of the Sequential model in Keras?",
            "options": [
                "It allows multiple inputs and outputs",
                "It creates a linear stack of layers",
                "It automatically selects the best architecture",
                "It only works for convolutional networks"
            ],
            "correct_answer": 1,
            "explanation": "The Sequential model is designed for simple layer-by-layer architectures where each layer has exactly one input and one output tensor"
        },
        {
            "id": 456,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import the necessary modules for neural network regression:",
            "code_snippet": "from tensorflow import ______",
            "options": [
                "keras",
                "tensorflow",
                "nn",
                "models"
            ],
            "correct_answer": 0,
            "explanation": "Keras is the high-level neural networks API that runs on top of TensorFlow"
        },
        {
            "id": 457,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "Why is it important to set random_state in train_test_split?",
            "options": [
                "To ensure reproducible results across runs",
                "To make training faster",
                "To improve model accuracy",
                "To reduce memory usage"
            ],
            "correct_answer": 0,
            "explanation": "random_state ensures that the data splitting is consistent across different runs, making experiments reproducible"
        },
        {
            "id": 458,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to train a model for 20 epochs with validation:",
            "code_snippet": "history = model.fit(X_train, y_train, epochs=20, ______=(X_test, y_test))",
            "options": [
                "validation_data",
                "val_data",
                "test_data",
                "eval_data"
            ],
            "correct_answer": 0,
            "explanation": "validation_data parameter takes a tuple of (X_test, y_test) to evaluate the model during training"
        },
        {
            "id": 459,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the typical range of output values for a sigmoid activation function?",
            "options": [
                "0 to 1",
                "-1 to 1",
                "0 to infinity",
                "Negative infinity to positive infinity"
            ],
            "correct_answer": 0,
            "explanation": "Sigmoid function outputs values between 0 and 1, making it suitable for probability outputs"
        },
        {
            "id": 460,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "In the context of the diabetes dataset, what type of problem is being solved?",
            "options": [
                "Regression - predicting continuous values",
                "Binary classification - predicting two classes",
                "Multi-class classification - predicting multiple classes",
                "Clustering - grouping similar samples"
            ],
            "correct_answer": 0,
            "explanation": "The diabetes dataset involves predicting a quantitative measure of disease progression, which is a regression problem"
        },
        {
            "id": 461,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the main advantage of using ReLU over sigmoid activation in hidden layers?",
            "options": [
                "ReLU helps mitigate the vanishing gradient problem",
                "ReLU outputs probabilities between 0 and 1",
                "ReLU is more computationally expensive",
                "ReLU works better for output layers"
            ],
            "correct_answer": 0,
            "explanation": "ReLU doesn't saturate for positive inputs, which helps prevent vanishing gradients and allows for faster convergence in deep networks"
        },
        {
            "id": 462,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a Sequential model instance:",
            "code_snippet": "model = ______()",
            "options": [
                "Sequential",
                "Model",
                "Network",
                "KerasModel"
            ],
            "correct_answer": 0,
            "explanation": "Sequential() creates a new Sequential model instance for building neural networks layer by layer"
        },
        {
            "id": 463,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What does it indicate when training loss decreases but validation loss increases?",
            "options": [
                "The model is underfitting",
                "The model is overfitting",
                "The learning rate is too low",
                "The batch size is too small"
            ],
            "correct_answer": 1,
            "explanation": "When training loss decreases but validation loss increases, it typically indicates overfitting - the model is memorizing training data rather than learning general patterns"
        },
        {
            "id": 464,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to add a hidden layer with 32 neurons and tanh activation:",
            "code_snippet": "model.add(Dense(32, ______='tanh'))",
            "options": [
                "activation",
                "act",
                "function",
                "activ"
            ],
            "correct_answer": 0,
            "explanation": "The parameter name for specifying the activation function in Dense layers is 'activation'"
        },
        {
            "id": 465,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Why is the diabetes dataset suitable for regression with neural networks?",
            "options": [
                "It has continuous target values and multiple features",
                "It has categorical target values",
                "It has only two features",
                "It requires image processing"
            ],
            "correct_answer": 0,
            "explanation": "The diabetes dataset contains continuous target values (disease progression) and multiple input features, making it ideal for regression problems with neural networks"
        },
        {
            "id": 466,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "What is the purpose of the input layer in a neural network?",
            "options": [
                "To specify the shape of input data",
                "To add non-linearity",
                "To compute the final output",
                "To regularize the model"
            ],
            "correct_answer": 0,
            "explanation": "The input layer defines the expected input shape and doesn't contain any trainable parameters - it simply passes the input to the first hidden layer"
        },
        {
            "id": 467,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to split the diabetes dataset with 30% test data:",
            "code_snippet": "X_train, X_test, y_train, y_test = train_test_split(X, y, ______=0.3)",
            "options": [
                "test_size",
                "split_size",
                "test_ratio",
                "validation_size"
            ],
            "correct_answer": 0,
            "explanation": "test_size parameter specifies the proportion of the dataset to include in the test split"
        },
        {
            "id": 468,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "How does batch size affect the training process?",
            "options": [
                "Smaller batches provide noisier but more frequent updates",
                "Larger batches always lead to better convergence",
                "Batch size doesn't affect training dynamics",
                "Smaller batches reduce memory usage"
            ],
            "correct_answer": 0,
            "explanation": "Smaller batch sizes result in noisier gradient estimates but more frequent weight updates, which can help escape local minima"
        },
        {
            "id": 469,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with multiple hidden layers:",
            "code_snippet": "model.add(Dense(64, activation='relu'))\nmodel.add(Dense(32, ______='relu'))",
            "options": [
                "activation",
                "act",
                "function",
                "layer_activation"
            ],
            "correct_answer": 0,
            "explanation": "Each Dense layer can specify its own activation function using the 'activation' parameter"
        },
        {
            "id": 470,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the key difference between regression and classification in neural networks?",
            "options": [
                "Regression predicts continuous values, classification predicts discrete classes",
                "Regression uses softmax, classification uses linear activation",
                "Regression requires more layers",
                "Classification always uses sigmoid activation"
            ],
            "correct_answer": 0,
            "explanation": "Regression predicts continuous numerical values, while classification predicts discrete class labels - this affects the output layer design and loss function"
        },
        {
            "id": 471,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "Why do we need to compile a neural network model before training?",
            "options": [
                "To configure the learning process with optimizer, loss, and metrics",
                "To convert the model to executable code",
                "To initialize random weights",
                "To validate the model architecture"
            ],
            "correct_answer": 0,
            "explanation": "Compiling configures the model for training by specifying the optimizer, loss function, and evaluation metrics"
        },
        {
            "id": 472,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to access the target values from diabetes dataset:",
            "code_snippet": "y = diabetes['______']",
            "options": [
                "target",
                "y",
                "labels",
                "output"
            ],
            "correct_answer": 0,
            "explanation": "The target values in scikit-learn datasets are stored under the 'target' key"
        },
        {
            "id": 473,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What is the effect of increasing the number of epochs too much?",
            "options": [
                "Increased risk of overfitting",
                "Faster convergence",
                "Better generalization",
                "Reduced model capacity"
            ],
            "correct_answer": 0,
            "explanation": "Too many epochs can lead to overfitting as the model continues to learn noise and specific patterns in the training data"
        },
        {
            "id": 474,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Which of these is NOT a typical characteristic of a good regression model?",
            "options": [
                "High training accuracy with poor validation performance",
                "Consistent performance on training and validation data",
                "Decreasing loss over epochs",
                "Reasonable prediction error on new data"
            ],
            "correct_answer": 0,
            "explanation": "High training performance with poor validation performance indicates overfitting, which is not desirable"
        },
        {
            "id": 475,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to store training history for analysis:",
            "code_snippet": "______ = model.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))",
            "options": [
                "history",
                "training_history",
                "results",
                "log"
            ],
            "correct_answer": 0,
            "explanation": "The fit() method returns a History object that contains training metrics, which can be stored for plotting and analysis"
        },
        {
            "id": 476,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the primary role of the loss function in neural network training?",
            "options": [
                "To measure how well the model's predictions match the true values",
                "To determine the learning rate",
                "To select the best activation function",
                "To initialize the model weights"
            ],
            "correct_answer": 0,
            "explanation": "The loss function quantifies the difference between predicted and actual values, providing the objective that the optimizer tries to minimize"
        },
        {
            "id": 477,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import train_test_split from scikit-learn:",
            "code_snippet": "from sklearn.model_selection import ______",
            "options": [
                "train_test_split",
                "split_data",
                "train_split",
                "data_split"
            ],
            "correct_answer": 0,
            "explanation": "train_test_split is the function used to split datasets into training and testing subsets"
        },
        {
            "id": 478,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "Why might a neural network with too many hidden layers perform poorly?",
            "options": [
                "Vanishing gradients and overfitting",
                "Too few parameters to learn",
                "Insufficient non-linearity",
                "Automatic feature selection"
            ],
            "correct_answer": 0,
            "explanation": "Very deep networks can suffer from vanishing gradients during backpropagation and are more prone to overfitting without proper regularization"
        },
        {
            "id": 479,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with a specific input shape for 10 features:",
            "code_snippet": "model.add(Input(shape=(______,)))",
            "options": [
                "10",
                "X_train.shape[1]",
                "X.shape[1]",
                "All of the above"
            ],
            "correct_answer": 3,
            "explanation": "All options are valid ways to specify input shape for 10 features - using the actual number 10, or dynamically using .shape[1] from the data"
        },
        {
            "id": 480,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the main advantage of using the Adam optimizer over basic SGD?",
            "options": [
                "Adaptive learning rates for each parameter",
                "Faster computation time",
                "Fewer hyperparameters to tune",
                "Better for small datasets only"
            ],
            "correct_answer": 0,
            "explanation": "Adam adapts the learning rate for each parameter individually and includes momentum, which often leads to faster and more stable convergence"
        },
        {
            "id": 481,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "In the diabetes dataset context, what does the target variable represent?",
            "options": [
                "A quantitative measure of disease progression",
                "Whether a patient has diabetes or not",
                "The type of diabetes diagnosis",
                "Patient age in years"
            ],
            "correct_answer": 0,
            "explanation": "The diabetes dataset target is a continuous value representing disease progression one year after baseline, making it a regression problem"
        },
        {
            "id": 482,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to train a model without storing history:",
            "code_snippet": "model.______(X_train, y_train, epochs=10)",
            "options": [
                "fit",
                "train",
                "run",
                "execute"
            ],
            "correct_answer": 0,
            "explanation": "The fit() method is used to train the model on the provided data for the specified number of epochs"
        },
        {
            "id": 483,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What is the significance of monitoring both training and validation loss?",
            "options": [
                "To detect overfitting and determine early stopping",
                "To calculate model accuracy",
                "To select the best optimizer",
                "To determine the optimal batch size"
            ],
            "correct_answer": 0,
            "explanation": "Comparing training and validation loss helps identify when the model starts overfitting (when validation loss stops improving or increases while training loss continues to decrease)"
        },
        {
            "id": 484,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to use a custom batch size during training:",
            "code_snippet": "model.fit(X_train, y_train, epochs=10, batch_size=______)",
            "options": [
                "32",
                "16",
                "64",
                "Any positive integer"
            ],
            "correct_answer": 3,
            "explanation": "batch_size can be any positive integer, though typical values are powers of 2 (16, 32, 64, 128, etc.) for hardware optimization"
        },
        {
            "id": 485,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Why is Mean Squared Error particularly suitable for regression problems?",
            "options": [
                "It penalizes large errors more heavily due to squaring",
                "It works only with normalized data",
                "It's the fastest loss function to compute",
                "It automatically handles categorical variables"
            ],
            "correct_answer": 0,
            "explanation": "MSE squares the errors, which means larger errors contribute disproportionately more to the total loss, encouraging the model to focus on reducing large prediction errors"
        },
        {
            "id": 486,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "What is the purpose of the Dense layer in Keras?",
            "options": [
                "To create fully connected layers where each neuron connects to all previous layer neurons",
                "To add convolutional filters for image processing",
                "To implement recurrent connections for sequence data",
                "To regularize the model and prevent overfitting"
            ],
            "correct_answer": 0,
            "explanation": "Dense layers are fully connected layers where each neuron receives input from all neurons in the previous layer and connects to all neurons in the next layer"
        },
        {
            "id": 487,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to access the feature data from diabetes dataset:",
            "code_snippet": "X = diabetes['______']",
            "options": [
                "data",
                "features",
                "X",
                "inputs"
            ],
            "correct_answer": 0,
            "explanation": "The feature data in scikit-learn datasets is stored under the 'data' key"
        },
        {
            "id": 488,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "How does the choice of activation function affect gradient flow during backpropagation?",
            "options": [
                "Some functions can cause vanishing or exploding gradients",
                "Activation functions don't affect gradient flow",
                "All functions provide the same gradient behavior",
                "Only output layer activation affects gradients"
            ],
            "correct_answer": 0,
            "explanation": "Different activation functions have different gradient properties - sigmoid/tanh can cause vanishing gradients, while ReLU can cause dying neurons, both affecting how well gradients flow during backpropagation"
        },
        {
            "id": 489,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the relationship between batch size and training stability?",
            "options": [
                "Larger batches provide more stable gradient estimates",
                "Smaller batches always provide more stable training",
                "Batch size doesn't affect training stability",
                "Only very small batches (1-2) are stable"
            ],
            "correct_answer": 0,
            "explanation": "Larger batch sizes average gradients over more samples, resulting in more stable (less noisy) gradient estimates and smoother convergence"
        },
        {
            "id": 490,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with increasing then decreasing layer sizes:",
            "code_snippet": "model.add(Dense(64, activation='relu'))\nmodel.add(Dense(32, activation='relu'))\nmodel.add(Dense(______, activation='relu'))",
            "options": [
                "16",
                "128",
                "64",
                "32"
            ],
            "correct_answer": 0,
            "explanation": "A common architecture pattern is to gradually decrease layer sizes (64â32â16) to compress information and extract higher-level features"
        },
        {
            "id": 491,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the key difference between training a neural network and traditional machine learning models?",
            "options": [
                "Neural networks learn hierarchical feature representations automatically",
                "Neural networks require less data",
                "Neural networks don't need feature scaling",
                "Neural networks always converge faster"
            ],
            "correct_answer": 0,
            "explanation": "Neural networks automatically learn hierarchical feature representations through multiple layers, whereas traditional ML often requires manual feature engineering"
        },
        {
            "id": 492,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a simple neural network with one hidden layer:",
            "code_snippet": "model = Sequential()\nmodel.add(Input(shape=(10,)))\nmodel.add(Dense(32, activation='relu'))\nmodel.add(Dense(______))",
            "options": [
                "1",
                "32",
                "10",
                "64"
            ],
            "correct_answer": 0,
            "explanation": "For regression problems, the final layer should have 1 neuron to output a single continuous value"
        },
        {
            "id": 493,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "Why might a neural network with tanh activation perform differently than one with ReLU?",
            "options": [
                "Tanh outputs are centered around zero which can help with gradient flow",
                "ReLU is always better for all problems",
                "Tanh requires more computational resources",
                "ReLU outputs are bounded between -1 and 1"
            ],
            "correct_answer": 0,
            "explanation": "Tanh outputs are zero-centered (-1 to 1), which can help with gradient flow during training, while ReLU outputs are only positive (0 to infinity)"
        },
        {
            "id": 494,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to compile a model with both loss and metrics:",
            "code_snippet": "model.compile(optimizer='adam', loss=MeanSquaredError(), ______=['mae'])",
            "options": [
                "metrics",
                "metric",
                "evaluation",
                "monitor"
            ],
            "correct_answer": 0,
            "explanation": "The 'metrics' parameter allows specifying additional evaluation metrics like MAE (Mean Absolute Error) to monitor during training"
        },
        {
            "id": 495,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the role of the learning rate in neural network optimization?",
            "options": [
                "It controls the step size during weight updates",
                "It determines the number of layers",
                "It selects the activation function",
                "It sets the batch size"
            ],
            "correct_answer": 0,
            "explanation": "The learning rate determines how much to adjust the model weights with respect to the loss gradient - too high may overshoot minima, too low may converge slowly"
        },
        {
            "id": 496,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "In the context of the diabetes dataset, what does X_train represent?",
            "options": [
                "The feature values used for training the model",
                "The target values for testing",
                "The validation dataset",
                "The preprocessed features only"
            ],
            "correct_answer": 0,
            "explanation": "X_train contains the input features (age, BMI, blood pressure, etc.) that the model uses during training to learn patterns"
        },
        {
            "id": 497,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to import the diabetes dataset:",
            "code_snippet": "from sklearn.datasets import ______",
            "options": [
                "load_diabetes",
                "diabetes",
                "get_diabetes",
                "load_dataset"
            ],
            "correct_answer": 0,
            "explanation": "load_diabetes is the specific function to import the diabetes dataset from scikit-learn"
        },
        {
            "id": 498,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What is the 'dying ReLU' problem and how can it be addressed?",
            "options": [
                "Neurons that only output zero, addressed using Leaky ReLU or proper initialization",
                "Neurons that output very large values, fixed with gradient clipping",
                "Neurons that stop learning after few epochs, fixed with more data",
                "Neurons that become too sensitive, fixed with regularization"
            ],
            "correct_answer": 0,
            "explanation": "Dying ReLU occurs when neurons get stuck outputting only zero (negative inputs), which can be mitigated using Leaky ReLU, proper weight initialization, or different activation functions"
        },
        {
            "id": 499,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with mixed activation functions:",
            "code_snippet": "model.add(Dense(16, activation='relu'))\nmodel.add(Dense(8, activation='______'))\nmodel.add(Dense(1))",
            "options": [
                "tanh",
                "softmax",
                "linear",
                "sigmoid"
            ],
            "correct_answer": 0,
            "explanation": "Using different activation functions like ReLU and tanh in different layers can help the network learn diverse types of non-linear relationships"
        },
        {
            "id": 500,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Why is it important to use both training and testing data in model development?",
            "options": [
                "To evaluate how well the model generalizes to unseen data",
                "To make the model train faster",
                "To reduce the number of parameters",
                "To automatically select the best architecture"
            ],
            "correct_answer": 0,
            "explanation": "Testing data provides an unbiased evaluation of the model's performance on unseen data, helping assess its generalization capability and detect overfitting"
        },
        {
            "id": 501,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "What does the term 'epoch' mean in neural network training?",
            "options": [
                "One complete pass through the entire training dataset",
                "One weight update using a single batch",
                "The time to process one sample",
                "The convergence point of the model"
            ],
            "correct_answer": 0,
            "explanation": "An epoch represents one complete cycle through the entire training dataset, which may consist of multiple batches depending on the batch size"
        },
        {
            "id": 502,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to define a Sequential model with input layer:",
            "code_snippet": "model = ______()\nmodel.add(Input(shape=(X_train.shape[1],)))",
            "options": [
                "Sequential",
                "Model",
                "Network",
                "Keras"
            ],
            "correct_answer": 0,
            "explanation": "Sequential() creates a linear stack of layers, which is the most common way to build neural networks in Keras"
        },
        {
            "id": 503,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "How does the number of features in the diabetes dataset affect the input layer?",
            "options": [
                "The input layer shape must match the number of features",
                "The input layer size is always fixed at 10",
                "The number of features determines the number of hidden layers",
                "Features don't affect the input layer design"
            ],
            "correct_answer": 0,
            "explanation": "The input layer's shape parameter must match the number of features in the dataset, which for the diabetes dataset is 10 features after normalization"
        },
        {
            "id": 504,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the purpose of using multiple metrics during model compilation?",
            "options": [
                "To get different perspectives on model performance",
                "To make training faster",
                "To reduce memory usage",
                "To automatically tune hyperparameters"
            ],
            "correct_answer": 0,
            "explanation": "Different metrics (like MSE and MAE) provide complementary views of model performance - MSE emphasizes large errors, MAE gives equal weight to all errors"
        },
        {
            "id": 505,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to train with a specific batch size and store history:",
            "code_snippet": "______ = model.fit(X_train, y_train, epochs=15, batch_size=32, validation_data=(X_test, y_test))",
            "options": [
                "history",
                "results",
                "training_log",
                "output"
            ],
            "correct_answer": 0,
            "explanation": "Storing the return value of fit() in a variable called 'history' allows access to training metrics for visualization and analysis"
        },
        {
            "id": 506,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the fundamental building block of a neural network?",
            "options": [
                "The neuron (perceptron) with weights, bias, and activation",
                "The convolutional filter",
                "The loss function",
                "The optimizer"
            ],
            "correct_answer": 0,
            "explanation": "The basic building block is the neuron (perceptron), which takes weighted inputs, adds a bias, and applies an activation function to produce output"
        },
        {
            "id": 507,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to create a model with sigmoid activation in hidden layer:",
            "code_snippet": "model.add(Dense(10, activation='______'))",
            "options": [
                "sigmoid",
                "relu",
                "tanh",
                "softmax"
            ],
            "correct_answer": 0,
            "explanation": "Sigmoid activation can be used in hidden layers, though it's less common than ReLU due to potential vanishing gradient issues"
        },
        {
            "id": 508,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "Why is proper weight initialization important in neural networks?",
            "options": [
                "It helps prevent vanishing/exploding gradients and speeds up convergence",
                "It determines the final model accuracy",
                "It replaces the need for activation functions",
                "It automatically selects the best architecture"
            ],
            "correct_answer": 0,
            "explanation": "Proper initialization ensures gradients flow well during backpropagation, preventing issues like vanishing/exploding gradients and helping the model converge faster"
        },
        {
            "id": 509,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to use SGD optimizer with specific learning rate:",
            "code_snippet": "from keras.optimizers import SGD\noptimizer = SGD(______=0.01)",
            "options": [
                "learning_rate",
                "lr",
                "rate",
                "alpha"
            ],
            "correct_answer": 1,
            "explanation": "The parameter name for setting learning rate in Keras optimizers is 'lr' (learning_rate is also accepted in newer versions)"
        },
        {
            "id": 510,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the main advantage of using neural networks for regression over linear regression?",
            "options": [
                "Neural networks can model complex non-linear relationships",
                "Neural networks always require less data",
                "Neural networks are faster to train",
                "Neural networks don't need feature scaling"
            ],
            "correct_answer": 0,
            "explanation": "Neural networks with non-linear activations can learn complex, non-linear patterns in data, while linear regression is limited to linear relationships"
        },
        {
            "id": 511,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "In the model.fit() method, what do X_train and y_train represent?",
            "options": [
                "Training features and corresponding target values",
                "Test features and predictions",
                "Validation data and labels",
                "Input shapes and output sizes"
            ],
            "correct_answer": 0,
            "explanation": "X_train contains the input features for training, and y_train contains the corresponding target values that the model learns to predict"
        },
        {
            "id": 512,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to evaluate model performance on test data:",
            "code_snippet": "test_loss = model.______(X_test, y_test)",
            "options": [
                "evaluate",
                "test",
                "predict",
                "score"
            ],
            "correct_answer": 0,
            "explanation": "The evaluate() method returns the loss value and any metrics for the model on test data"
        },
        {
            "id": 513,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "What is gradient descent and how does it relate to neural network training?",
            "options": [
                "An optimization algorithm that minimizes loss by updating weights in the direction of steepest descent",
                "A method for selecting the best activation function",
                "A technique for initializing model weights",
                "A process for splitting data into training and test sets"
            ],
            "correct_answer": 0,
            "explanation": "Gradient descent is the fundamental optimization algorithm that adjusts model weights by moving in the direction that reduces the loss function most rapidly"
        },
        {
            "id": 514,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to make predictions with a trained model:",
            "code_snippet": "predictions = model.______(X_test)",
            "options": [
                "predict",
                "forward",
                "run",
                "test"
            ],
            "correct_answer": 0,
            "explanation": "The predict() method generates output predictions for the input samples using the trained model"
        },
        {
            "id": 515,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "Why might you choose different numbers of neurons in different hidden layers?",
            "options": [
                "To create an information bottleneck or feature hierarchy",
                "To make the model train faster",
                "To reduce the number of parameters",
                "To ensure all layers have the same computational cost"
            ],
            "correct_answer": 0,
            "explanation": "Using decreasing layer sizes (e.g., 64â32â16) can create a feature hierarchy where each layer extracts increasingly abstract representations"
        },
        {
            "id": 516,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "beginner",
            "question": "What is the purpose of the model.summary() method in Keras?",
            "options": [
                "To display the model architecture and parameter counts",
                "To calculate model accuracy",
                "To save the model to disk",
                "To plot training history"
            ],
            "correct_answer": 0,
            "explanation": "summary() provides a concise overview of the model architecture, including layer types, output shapes, and number of trainable parameters"
        },
        {
            "id": 517,
            "type": "code_completion",
            "category": "neural_networks_basics",
            "difficulty": "beginner",
            "question": "Complete the code to show model architecture:",
            "code_snippet": "model.______()",
            "options": [
                "summary",
                "describe",
                "architecture",
                "info"
            ],
            "correct_answer": 0,
            "explanation": "The summary() method displays the model's layer-by-layer architecture and parameter counts"
        },
        {
            "id": 518,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "advanced",
            "question": "How does backpropagation work in neural network training?",
            "options": [
                "It calculates gradients of the loss with respect to weights using chain rule",
                "It initializes random weights for the network",
                "It selects the best learning rate automatically",
                "It determines the optimal number of layers"
            ],
            "correct_answer": 0,
            "explanation": "Backpropagation efficiently computes gradients by applying the chain rule from the output layer back to the input layer, enabling weight updates via gradient descent"
        },
        {
            "id": 519,
            "type": "multiple_choice",
            "category": "neural_networks_concepts",
            "difficulty": "intermediate",
            "question": "What is the relationship between model complexity and overfitting?",
            "options": [
                "More complex models are more prone to overfitting without proper regularization",
                "Complex models always generalize better",
                "Simple models overfit more easily",
                "Model complexity doesn't affect overfitting"
            ],
            "correct_answer": 0,
            "explanation": "More complex models (with more layers/neurons) have higher capacity to memorize training data, making them more susceptible to overfitting without techniques like dropout or regularization"
        },
        {
            "id": 520,
            "type": "code_completion",
            "category": "neural_networks_advanced",
            "difficulty": "intermediate",
            "question": "Complete the code to create a model with decreasing layer sizes:",
            "code_snippet": "model.add(Dense(128, activation='relu'))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dense(______, activation='relu'))",
            "options": [
                "32",
                "256",
                "128",
                "16"
            ],
            "correct_answer": 0,
            "explanation": "A common pattern is to gradually decrease layer sizes (128â64â32) to compress information and build hierarchical feature representations"
        }
    ]
}